{"version":3,"sources":["ga.js","plugins.js"],"names":["GA","VERSION","plugins","undefined","custom","create","width","height","setup","assetsToLoad","load","gameLoop","ga","update","canvas","render","current","Date","now","_startTime","elapsed","_frameDuration","_lag","setPosition","child","sprite","_previousX","x","_previousY","y","children","length","forEach","capturePreviousSpritePositions","lagOffset","buttons","state","style","cursor","i","button","stage","dragAndDrop","updateDragAndDrop","paused","updateFunctions","l","updateFunction","o","scaleX","vx","vy","scaleY","pivotX","pivotY","shadowColor","shadowOffsetX","parent","_layer","shadowOffsetY","_circular","blendMode","_alpha","addChild","removeChild","push","Error","splice","indexOf","swapChildren","child1","child2","index1","index2","sprites","add","spritesToAdd","Array","prototype","slice","call","arguments","spritesToRemove","a","b","yOffset","xOffset","compensateForParentPosition","halfWidth","halfHeight","putRight","putBottom","putLeft","Object","gx","gy","enumerable","get","this","configurable","position","relativeAlpha","value","centerX","centerY","layer","set","circular","sort","byLayer","makeCircular","_draggable","radius","draggable","draggableSprites","_interactive","interactive","makeInteractive","rectangle","globalBounds","empty","remove","defineProperties","makeDisplayObject","press","pointer","release","over","out","enabled","tap","pressed","frames","hit","hitTestSprite","show","subtype","tapped","hoverOver","action","imageFileName","jsonFileName","assets","addStatePlayer","frameCounter","numberOfFrames","startFrame","endFrame","frameNumber","keyboard","keyCode","key","isDown","leftArrow","upArrow","rightArrow","downHandler","event","code","isUp","upHandler","preventDefault","bind","document","createElement","dips","setAttribute","body","ctx","getContext","group","makeStage","_y","_x","scale","downTime","elapsedTime","dragSprite","dragOffsetX","moveHandler","targetTouches","pageX","dragOffsetY","target","offsetLeft","pageY","offsetTop","touchstartHandler","addEventListener","Math","abs","top","touchmoveHandler","sqrt","left","right","bottom","some","makePointer","downArrow","space","makeKeys","tweens","assetFilePaths","_fps","interpolate","start","whenLoaded","pause","hidePointer","showPointer","backgroundColor","spritesArray","diameter","spritesToGroup","calculateSize","_newHeight","_newWidth","fillStyle","strokeStyle","lineWidth","beginPath","mask","clip","rect","circle","stroke","fill","line","arc","ax","bx","ay","by","moveTo","lineTo","lineJoin","content","font","textBaseline","text","translate","measureText","frame","source","image","fillText","filmstrip","positions","columns","rows","data","arrayOfPositions","imageName","frameWidth","frameHeight","spacing","floor","loop","_currentFrame","tilesetFrame","sourceWidth","sourceHeight","setTexture","sourceX","Image","sourceY","gotoAndStop","w","h","defineProperty","drawImage","json","playing","sequenceArray","reset","fps","timerInterval","setInterval","currentFrame","frameRate","clearRect","clearInterval","playSequence","play","renderY","displaySprite","visible","save","rotate","rotation","renderX","shadowBlur","globalAlpha","j","shadow","restore","globalCompositeOperation","toLoad","loaded","imageExtensions","sources","src","self","fontFamily","extension","split","pop","appendChild","newStyle","loadHandler","name","soundSprite","fontExtensions","fontFace","xhr","readyState","createTextNode","head","audioExtensions","makeSound","jsonExtensions","console","file","open","createTilesetFrames","JSON","parse","responseText","send","log","baseUrl","replace","meta","keys","tilesetImage","window","global","exports","perf","fixSetTarget","param","setTargetAtTime","setTargetValueAtTime","hasOwnProperty","AudioContext","webkitAudioContext","createDelay","createDelayNode","internal_createGain","createGain","createJavaScriptNode","gain","node","delayTime","maxDelayTime","internal_createDelay","internal_createBufferSource","createBufferSource","duration","offset","when","playbackRate","noteOn","internal_createDynamicsCompressor","threshold","attack","createDynamicsCompressor","knee","internal_createBiquadFilter","frequency","createBiquadFilter","internal_createOscillator","detune","createOscillator","stop","noteOff","apis","doc","type","api","w3","element","createEvent","dispatch","events","change","e","dispatchEvent","exit","error","webkit","request","moz","ms","vendor","apply","internal_move","move","distance","s1","s2","followEase","follower","leader","speed","followConstant","rotatingSprite","centerSprite","point","angle","cos","sin","rotateAroundPoint","pointX","pointY","distanceX","distanceY","wait","setTimeout","min","max","random","randomFloat","world","callBack","worldCamera","rightInnerBoundary","leftInnerBoundary","bottomInnerBoundary","follow","topInnerBoundary","centerOver","scaleToWindow","margin","center","innerHeight","paddingLeft","paddingRight","innerWidth","scaled","marginLeft","marginRight","marginTop","paddingTop","paddingBottom","display","ua","shakingSprite","shakingSprites","updateShake","maxHeight","minHeight","updateShakingSprites","magnitude","angular","angularShake","counter","numberOfShakes","startX","startY","startAngle","magnitudeUnit","randomInt","tiltAngle","updateTweens","pow","acceleration","tween","cubicBezier","PI","c","d","t2","t","sineCubed","sineSquared","ease","linear","smoothstep","smoothstepSquared","smoothstepCubed","accelerationCubed","deceleration","decelerationCubed","tweenProperty","property","startValue","endValue","totalFrames","spline","p0","p1","p2","p3","yoyo","startMagnitude","delayBeforeRepeat","typeArray","parseInt","endMagnitude","stringify","normalizedTime","curvedTime","end","onComplete","fadeOut","alpha","fadeIn","pulse","newTween","tweenPropertyArguments","minAlpha","makeTween","tweensToAdd","completionCounter","completed","endX","endY","endScaleX","breathe","endScaleY","scaleFactor","yStartMagnitude","friction","bounceX","xStartMagnitude","bounceY","scaleFactorX","strobe","bounce","removeTween","tweenObject","wobble","scaleFactorY","yEndMagnitude","xEndMagnitude","pointsArray","followCurve","walkPath","delayBetweenSections","p","originalPathArray","makePath","currentPoint","currentCurve","delayBeforeContinue","pathArray","reverse","shooter","bullet","walkCurve","curveArray","container","grid","cellWidth","shoot","offsetFromCenter","bulletSpeed","bulletArray","bulletSprite","progressBar","foregroundColor","percentage","cellHeight","centerCell","initialized","makeSprite","extra","maxWidth","ratio","createGrid","minRotationSpeed","maxRotationSpeed","backBar","frontBar","numberOfParticles","maxAngle","angles","minAngle","particle","spriteFunction","particleEffect","gravity","randomSpacing","minSize","maxSize","minSpeed","maxSpeed","minScaleSpeed","maxScaleSpeed","minAlphaSpeed","maxAlphaSpeed","particleFunction","emitter","emitParticle","size","scaleSpeed","tileWidth","tileHeight","rotationSpeed","updateParticle","alphaSpeed","particles","makeParticle","updateParticles","interval","tileY","tileGrid","difference","tilingSprite","collision","round","s","_tileX","tileX","shape","_tileY","outsideBounds","bounds","c2","combinedHalfWidths","combinedHalfHeights","contain","r1","c1y","mass","hitTestCircleRectangle","hitTestPoint","r1x","c1x","region","hitTestCircle","c1","totalRadii","hitTestRectangle","r2","rectangleCollision","r1y","overlapX","overlapY","circleCollision","combinedRadii","hitTestCirclePoint","quantumPadding","bounceOffSurface","overlap","dx","dy","p1A","p2B","arrayOfCircles","dp1","dp2","lx","index","ly","tileheight","getTile","tile","movingCircleCollision","xSide","ySide","p1B","p2A","vyHalf","vxHalf","dp3","dp4","circlePointCollision","multipleCircleCollision","circleRectangleCollision","findCollisionType","aIsASprite","circleVsCircle","rectangleVsRectangle","react","bIsASprite","circleVsRectangle","widthInTiles","collisionPoints","spriteVsArray","getIndex","tilewidth","mapWidthInTiles","newMapArray","mapArray","gid","down","direction","surroundingCells","getPoints","ca","collisionArea","topLeft","topRight","bottomLeft","bottomRight","hitTestTile","gidToCheck","pointsToCheck","checkPoints","layerGroup","numberOfTilesetColumns","tiledMap","every","updateMap","spritesToUpdate","map","tileSprite","tileproperties","fourKeyController","up","tiledLayer","objects","object","getObject","objectName","searchForObject","foundObject","makeTiledWorld","tileset","heightInTiles","tilesets","imagewidth","fullscreenScale","requestFullScreen","requestFullscreen","opacity","texture","mapX","mapY","tilesetX","tilesetY","mapColumn","mapRow","tilesetColumn","tilesetRow","divNode","innerHTML","userAgent","toLowerCase","styleSheets","insertRule","String","enableFullscreen","alignFullscreen","scaleFullscreen","fullscreenEnabled","img","getObjects","namesOfObjects","objectNames","foundObjects","connect","exitFullscreen","panNode","screen","filterValue","feedbackNode","navigator","soundNode","startOffset","actx","currentTime","playFrom","feedbackValue","delayValue","exitKeyCodes","volumeNode","linearRampToValueAtTime","volume","createStereoPanner","createPanner","sound","soundFileName","filterNode","convolverNode","createConvolver","buffer","panValue","volumeValue","startTime","echo","feebackValue","soundEffect","reverb","pitchBendAmount","oscillator","destination","delayNode","pan","frequencyValue","convolver","impulseResponse","restart","addEcho","feedback","delay","setEcho","setReverb","decay","reverbImpulse","durationInSeconds","oscillatorNode","fade","addDissonance","d1Volume","d1","d2Volume","z","XMLHttpRequest","addReverb","decodeAudioData","response","hasLoaded","randomValue","dissonance","filter","pitchBend","d2","sampleRate","impulse","createBuffer","getChannelData","n"],"mappings":"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","file":"ga.all.min.js","sourcesContent":["// ==ClosureCompiler==\n// @output_file_name default.js\n// @compilation_level SIMPLE_OPTIMIZATIONS\n// @language ECMASCRIPT5\n// @fileoverview\n// @suppress {checkTypes | globalThis | checkVars}\n// ==/ClosureCompiler==\n\n/*\nWelcome to Ga's source code!\n============================\n\nIf you're reading this to find out how to use Ga, you've come to the wrong place.\nYou should take a look inside the `examples` folder.\nThere's a lot of cool stuff inside the `examples` folder, so check it out!\nBut if you want to find out how Ga works, this is the place to be.\n\nThis source code is organized into chapters.\nYes, chapters.\nJust think of it like *Lord of the Rings* or maybe *Harry Potter* and you'll be fine.\nActually, come to think of it, maybe it's more like *50 Shades of Grey*.\n\nEverything is in one big, hulking gainormous file.\nWhy?\nBecause `One Thing` is better than `Many Things`.\nJust use your text editor's search function to find what you're looking for.\nCourage, my love, you can do it!\n\nTable of contents\n-----------------\n\n*Prologue: Fixing the WebAudio API*\n\n`AudioContextMonkeyPatch.js`: Chris Wilson's cross browser patch for the WebAudio API.\n\n*Chapter 1: The game engine*\n\n`GA`:The global GA object.\n`ga`: A convenience function used to launch Ga.\n`Ga.create`: All the code that the Ga engine depends on.\n`ga.gameLoop`: the engine's game loop.\n`ga.update`: Calls the renderer, updates buttons and drag-and-drop objects each frame.\n`ga.start`: Used to get the engine up and running.\n`ga.pause`: pause the game loop.\n`ga.resume`: resume the game loop.\n`ga.hidePointer`: hide the pointer.\n`ga.showPointer`: show the pointer.\n`ga.fps`: get and set the game's frames per second.\n`ga.backgroundColor`: Set the canvas background color.\n\n*Chapter 2: Sprites*\n\n`makeDisplayObject`: Assigns all the basic properties common to all sprite types.\n`makeStage`: Create the stage object, which is the parent container for all the sprites.\n`ga.remove`: A global convenience method that will remove any sprite from its parent.\n`makeCircular`: Adds `diameter` and `radius` properties to sprites if a sprite's `circular` property is set to `true`.\n`ga.group`: Creates a parent group container that lets you compose game scenes or composite sprites.\n`ga.rectangle`: A basic colored rectangle sprite.\n`ga.circle`: A basic colored circle sprite.`\n`ga.line`: A line with start and end points.\n`ga.text`: Single line dynamic text.\n`ga.frame`: A function that returns an object defining the position of a sub-image in an Image object tileset.\n`ga.frames`: Lets you define a whole series of sub-images in a tileset.\n`ga.filmstrip:` Automatically returns an array of sub-image x and y coordinates for an animated image sequence.\n`ga.sprite`: Creates a sprite from an image, `frame`, `filmstrip`, or a frame from a texture atlas.\n`ga.button`: An interactive button with `up` `over` and `down` states. Optional `press` and `release` actions.\n`makeInteractive`: Assigns `press` and `release` actions to sprites and adds pointer interactivity.\n`ga.image`: Access Image objects by their file names.\n`ga.json`: Access JSON files by their file names.\n`ga.addStatePlayer`: Adds `play`, `stop`, `show`, and `playSequence` methods to sprites.\n\n*Chapter 3: Rendering*\n\n`ga.render`: Ga's canvas rendering method.\n\n*Chapter 4: Ga's helper objects and methods*\n\n`ga.assets`: All the game's assets (files) are stored in this object, and it has a `load` method that manages asset loading.\n`makePointer`: Makes a universal pointer object for the mouse and touch.\n`keyboard`: A method that creates `key` objects that listen for keyboard events.\n`makeKeys`: Used by Ga to create built-in references to the arrow keys and space bar.\n`byLayer`: An array sort method that's called when a sprite's `layer` property is changed.\n\n*/\n\n/*\nPrologue: Some necessary polyfills\n--------------------------\n\n/*\nChapter 1: The game engine\n--------------------------\n\nThis fist chapter is all about the Ga's game engine code. This is the code that\nlaunches Ga, sets the defaults, creates a canvas element, starts loading asssets,\nsetups up the current game state,\nand generally gets things up and running. This is probably the best place to start\nto learn how the engine works.\n\n*/\n\n//### GA\n//`GA` is the global instance of the program.\nvar GA = GA || {};\n\n//### GA.VERSION\n//The current version of the game engine.\nGA.VERSION = '0.0.1';\n\n//Set `plugins` and `custom` to an intial value of `undefined` to make\n//Google Closure Compiler happy\nGA.plugins = undefined;\nGA.custom = undefined;\n\n//### GA.create\n//The entire Ga program exists inside the `Ga.create` method. It\n//creates and returns a new instance of Ga, along with all the core\n//game engine functions. However, Ga won't actually start until you\n//call the `start` method from the applicaiton code, as you can see in\n//all the examples (in the `examples` folder).\nGA.create = function(width, height, setup, assetsToLoad, load) {\n\n  //The `ga` object is returned by this function. All the game\n  //engine's methods and properties are going to be attached to it.\n  var ga = {};\n\n  /*\n  ### Initialize the game engine\n  All of Ga's intializtion code happens here.\n  */\n\n  //Make the canvas element and add it to the DOM.\n  var dips = 1; //window.devicePixelRatio;\n  ga.canvas = document.createElement(\"canvas\");\n  ga.canvas.setAttribute(\"width\", width * dips);\n  ga.canvas.setAttribute(\"height\", height * dips);\n  ga.canvas.style.backgroundColor = \"black\";\n  document.body.appendChild(ga.canvas);\n\n  //Create the context as a property of the canvas.\n  ga.canvas.ctx = ga.canvas.getContext(\"2d\");\n\n  //Make the `stage`. The `stage` is the root container group\n  //for all the sprites and other groups.\n  ga.stage = makeStage();\n\n  //Initialize the pointer.\n  ga.pointer = makePointer();\n\n  //Make the keyboard keys (arrow keys and space bar.)\n  ga.key = makeKeys();\n\n  //An array to hold all the button sprites.\n  ga.buttons = [];\n\n  //Set `dragAndDrop` to `false` by default\n  //(Change it to `true` and set the `draggable` property on sprites\n  //to `true` to enable drag and drop.\n  ga.dragAndDrop = false;\n\n  //An array to store the draggable sprites.\n  ga.draggableSprites = [];\n\n  //An array to store the tweening functions.\n  ga.tweens = [];\n\n  //Set the game `state`.\n  ga.state = undefined;\n\n  //Set the user-defined `load` and `setup` states.\n  ga.load = load || undefined;\n  ga.setup = setup || undefined;\n\n  //The `setup` function is required, so throw an error if it's\n  //missing.\n  if (ga.setup === undefined) {\n    throw new Error(\n      \"Please supply the setup function in the constructor\"\n    );\n  }\n\n  //Get the user-defined array that lists the assets\n  //that have to load.\n  ga.assetFilePaths = assetsToLoad || undefined;\n\n  //A Boolean to let us pause the game.\n  ga.paused = false;\n\n  //The upper-limit frames per second that the game should run at.\n  //Ga defaults to 60 fps.\n  //Use the `fps` getter/setter to modify this value.\n  ga._fps = 60;\n  ga._startTime = Date.now();\n  ga._frameDuration = 1000 / ga._fps;\n  ga._lag = 0;\n\n  //Set sprite rendering position interpolation to\n  //`true` by default\n  ga.interpolate = true;\n\n  //An array that stores functions which should be run inside\n  //Ga's core `update` game loop. Just push any function you write\n  //into this array, and ga will run it in a continuous loop.\n  ga.updateFunctions = [];\n\n  /*\n  The canvas's x and y scale. These are set by getters and setter in\n  the code ahead. The scale is used in the `makeInteractive`\n  function for correct hit testing between the pointer and sprites\n  in a scaled canvas. Here's some application code you can use to\n  scale the Ga canvas to fit into the maximum size of the browser\n  window.\n\n      var scaleX = g.canvas.width / window.innerWidth,\n          scaleY = g.canvas.height / window.innerHeight,\n          //Or, scale to the height\n          //scaleX = window.innerWidth / g.canvas.width,\n          //scaleY = window.innerHeight / g.canvas.height,\n          scaleToFit = Math.min(scaleX, scaleY);\n\n      g.canvas.style.transformOrigin = \"0 0\";\n      g.canvas.style.transform = \"scale(\" + scaleToFit + \")\";\n\n      //Set Ga's scale\n      g.scale = scaleToFit;\n\n  */\n  //The game's screen's scale.\n  ga.scale = 1;\n\n  /*\n  ### Core game engine methods\n  This next sections contains all the important methods that the game engine needs to do its work.\n  */\n\n  //### gameLoop\n  //The engine's game loop. Ga uses a fixed timestep for logic update\n  //and rendering. This is mainly for simplicity. I'll probably\n  //migrate to a \"fixed timestep / variable rendering\" with\n  //interpolation in the\n  //next major update. For a working example, see:\n  //jsbin.com/tolime/1/edit\n  //If the `fps` isn't set, the maximum framerate is used.\n  //Use Ga's `fps` getter/setter (in the code ahead) to change the framerate\n  //\n  function gameLoop() {\n    requestAnimationFrame(gameLoop, ga.canvas);\n    if (ga._fps === undefined) {\n\n      //Run the code for each frame.\n      update();\n\t    ga.render(ga.canvas, 0);\n      \n    }\n\n    //If `fps` has been set, clamp the frame rate to that upper limit.\n    else {\n\n      //Calculate the time that has elapsed since the last frame\n      var current = Date.now(),\n        elapsed = current - ga._startTime;\n\n      if (elapsed > 1000) elapsed = ga._frameDuration;\n\n      //For interpolation:\n      ga._startTime = current;\n\n      //Add the elapsed time to the lag counter\n      ga._lag += elapsed;\n\n      //Update the frame if the lag counter is greater than or\n      //equal to the frame duration\n      while (ga._lag >= ga._frameDuration) {\n\n        //Capture the sprites' previous positions for rendering\n        //interpolation\n        capturePreviousSpritePositions();\n\n        //Update the logic\n        update();\n\n        //Reduce the lag counter by the frame duration\n        ga._lag -= ga._frameDuration;\n      }\n\n      //Calculate the lag offset and use it to render the sprites\n      var lagOffset = ga._lag / ga._frameDuration;\n      ga.render(ga.canvas, lagOffset);\n    }\n  }\n\n  //### capturePreviousSpritePositions\n  //This function is run in the game loop just before the logic update\n  //to store all the sprites' previous positions from the last frame.\n  //It allows the render function to interpolate the sprite positions\n  //for ultra-smooth sprite rendering at any frame rate\n  function capturePreviousSpritePositions() {\n    ga.stage.children.forEach(function(sprite) {\n      setPosition(sprite);\n    });\n\n    function setPosition(sprite) {\n      sprite._previousX = sprite.x;\n      sprite._previousY = sprite.y;\n      if (sprite.children && sprite.children.length > 0) {\n        sprite.children.forEach(function(child) {\n          setPosition(child);\n        });\n      }\n    }\n  }\n\n  //### update\n  //The things that should happen in the game loop.\n  function update() {\n\n    //Render the canvas.\n    //ga.render(ga.canvas);\n\n    //Update all the buttons in the game.\n    if (ga.buttons.length > 0) {\n      ga.canvas.style.cursor = \"auto\";\n      for (var i = ga.buttons.length - 1; i >= 0; i--) {\n        var button = ga.buttons[i];\n        button.update(ga.pointer, ga.canvas);\n        if (button.state === \"over\" || button.state === \"down\") {\n\n          //If the button (or interactive sprite) isn't the actual\n          //stage itself, change the cursor to a pointer.\n          if (!button.stage) {\n            ga.canvas.style.cursor = \"pointer\";\n          }\n        }\n      }\n    }\n\n    //Update the pointer for drag and drop.\n    if (ga.dragAndDrop) {\n      ga.pointer.updateDragAndDrop();\n    }\n\n    //Run the current game `state` function if it's been defined and\n    //the game isn't `paused`.\n    if (ga.state && !ga.paused) {\n      ga.state();\n    }\n\n    /*\n    Loop through all the functions in the `updateFunctions` array\n    and run any functions it contains. You can add any of your\n    own custom functions to this array like this:\n\n        var customFunction = function() {console.log(\"I'm in the game loop!);}\n        ga.updateFunctions.push(customFunction);\n\n    See the see the code in the `particleEffect` and `enableFullscreen`\n    section of the `plugins.js` file to see typical examples of how code can be\n    added to the game loop like this.\n    */\n\n    if (ga.updateFunctions.length !== 0) {\n      for (var l = 0; l < ga.updateFunctions.length; l++) {\n        var updateFunction = ga.updateFunctions[l];\n        updateFunction();\n      }\n    }\n  }\n\n  //### start\n  //The `start` method that gets the whole engine going. This needs to\n  //be called by the user from the game application code, right after\n  //Ga is instantiated.\n  ga.start = function() {\n    if (ga.assetFilePaths) {\n\n      //Use the supplied file paths to load the assets then run\n      //the user-defined `setup` function.\n      ga.assets.whenLoaded = function() {\n\n        //Clear the game `state` function for now to stop the loop.\n        ga.state = undefined;\n\n        //Call the `setup` function that was supplied by the user in\n        //Ga's constructor.\n        ga.setup();\n      };\n      ga.assets.load(ga.assetFilePaths);\n\n      //While the assets are loading, set the user-defined `load`\n      //function as the game state. That will make it run in a loop.\n      //You can use the `load` state to create a loading progress bar.\n      if (ga.load) {\n        ga.state = ga.load;\n      }\n    }\n\n    //If there aren't any assets to load,\n    //just run the user-defined `setup` function.\n    else {\n      ga.setup();\n    }\n\n    //Start the game loop.\n    gameLoop();\n  };\n\n  //### pause and resume\n  //Next are a few convenience methods for interacting with the game engine.\n  //This `pause` and `resume` methods start and stop the game loop to\n  //allow you to run functions that should only execute once.\n  ga.pause = function() {\n    ga.paused = true;\n  };\n  ga.resume = function() {\n    ga.paused = false;\n  };\n\n  //### hidePointer and showPointer\n  //Use `hidePointer` and `showPointer` to hide and display the\n  //pointer.\n  ga.hidePointer = function() {\n    ga.canvas.style.cursor = \"none\";\n  };\n  ga.showPointer = function() {\n    ga.canvas.style.cursor = \"auto\";\n  };\n\n  //Getters and setters for various game engine properties.\n  Object.defineProperties(ga, {\n\n    //### fps\n    //The `fps` getter/setter. Use it to set the frame rate.\n    fps: {\n      get: function() {\n        return ga._fps;\n      },\n      set: function(value) {\n        ga._fps = value;\n        ga._startTime = Date.now();\n        ga._frameDuration = 1000 / ga._fps;\n      },\n      enumerable: true,\n      configurable: true\n    },\n\n    //### backgroundColor\n    //Set the background color.\n    backgroundColor: {\n      set: function(value) {\n        ga.canvas.style.backgroundColor = value;\n      },\n      enumerable: true,\n      configurable: true\n    }\n  });\n\n\n\n  /*\n  Chapter 2: Sprites\n\n  This chapter contains all the code for Ga's scene graph and sprite system. Ga has 6 built-in sprite types\n  that have a wide range of applications for making games.\n\n  - `circle`: Circles with fill and stroke colors.\n  - `rectangle`: Rectangles with fill and stroke colors.\n  - `line`: Lines with a color, width, and start and end points.\n  - `text`: Single line dynamic text objects.\n  - `sprite`: A versatile sprite that can be made from a single image, a frame in a texture atlas,\n  a series of frames in sequence on a tileset or a series of frames in a texture atlas.\n  - `button`: An interactive button with three states (up, over and down)\n  and user-definable `press` and `release` actions.\n\n  All sprites can be nested inside other sprites with an `addChild` method, and parent\n  sprites have their own local coordinate system. Compose them together to make really complex game objects.\n\n  There are also two special sprites:\n\n  - `group`: This is a generic parent container is just used to group related sprites together.\n  Its `width` and `height` can be assigned manually but, if they aren't, the group's `width`\n  and `height` will match the area taken up by its children.\n  - `stage`: this is a special group that is created by the Ga engine when it's initialized. The\n  `stage` is the root container that contains everything in the game.\n\n  Use these building blocks for making most of the kinds of things you'll need in your games.\n  When sprites are created, they're assigned all of their basic properties with the help of a method called\n  `makeDisplayObject`. This gives the sprites all their default properties. After `makeDisplayObject` runs,\n  each sprite type is customized but their own constructor methods.\n  */\n\n  //### makeDisplayObject\n  //`makeDisplayObject` assigns properties that are common for all the sprite types.\n  function makeDisplayObject(o) {\n\n    //Initialize the position\n    o.x = 0;\n    o.y = 0;\n\n    //Initialize the velocity.\n    o.vx = 0;\n    o.vy = 0;\n\n    //Initialize the `width` and `height`.\n    o.width = 0;\n    o.height = 0;\n\n    //The sprite's width and height scale factors.\n    o.scaleX = 1;\n    o.scaleY = 1;\n\n    //The sprite's pivot point, which is its center of rotation.\n    //This is a percentage between 0.01 and 0.99.\n    o.pivotX = 0.5;\n    o.pivotY = 0.5;\n\n    //The sprite's rotation and visibility.\n    o.rotation = 0;\n    o.visible = true;\n\n    //Leave the sprite's `parent` as `undefined` for now.\n    //(Most will be added as children to the `stage` at a later step.)\n    o.parent = undefined;\n\n    //Is this the `stage` object? This will be `false` for every\n    //sprite, except the `stage`.\n    o.stage = false;\n\n    //Optional drop shadow properties.\n    //Set `shadow` to `true` if you want the sprite to display a\n    //shadow.\n    o.shadow = false;\n    o.shadowColor = \"rgba(100, 100, 100, 0.5)\";\n    o.shadowOffsetX = 3;\n    o.shadowOffsetY = 3;\n    o.shadowBlur = 3;\n\n    //Optional blend mode\n    o.blendMode = undefined;\n\n    //The sprite's private properties that are just used for internal\n    //calculations. All these properties will be changed or accessed through a matching getter/setter\n    o._alpha = 1;\n    o._draggable = undefined;\n\n    //The sprite's depth layer.\n    o._layer = 0;\n\n    //Is the sprite circular? If it is, it will be given a `radius`\n    //and `diameter`.\n    o._circular = false;\n\n    //Is the sprite `interactive`? If it is, it can become clickable\n    //or touchable.\n    o._interactive = false;\n\n    //properties to store the x and y positions from the previous\n    //frame. Use for rendering interpolation\n    o._previousX = undefined;\n    o._previousY = undefined;\n\n    //Add the sprite's container properties so that you can have\n    //a nested parent/child scene graph hierarchy.\n    //Create a `children` array that contains all the\n    //in this container.\n\n    o.children = [];\n    //The `addChild` method lets you add sprites to this container.\n\n    o.addChild = function(sprite) {\n\n      //Remove the sprite from its current parent, if it has one, and\n      //the parent isn't already this object\n      if (sprite.parent) {\n        sprite.parent.removeChild(sprite);\n      }\n\n      //Make this object the sprite's parent and\n      //add it to this object's `children` array.\n      sprite.parent = o;\n      o.children.push(sprite);\n\n      //Calculate the sprite's new width and height\n      //o.calculateSize();\n    };\n\n    //The `removeChild` method lets you remove a sprite from its\n    //parent container.\n    o.removeChild = function(sprite) {\n      if (sprite.parent === o) {\n        o.children.splice(o.children.indexOf(sprite), 1);\n      } else {\n        throw new Error(sprite + \"is not a child of \" + o);\n      }\n\n      //Calculate the sprite's new width and height\n      //o.calculateSize();\n    };\n\n    //Dynamically calculate the width and height of the sprite based\n    //on the size and position of the children it contains\n    /*\n    o.calculateSize = function() {\n      //Calculate the width based on the size of the largest child\n      //that this sprite contains\n      if (o.children.length > 0 && o.stage === false) {\n        for(var i = 0; i < o.children.length - 1; i++) {\n          var child = o.children[i];\n          if (child.x + child.width > o.width) {\n            o.width = child.x + child.width;\n          }\n          if (child.y + child.height > o.height) {\n            o.height = child.y + child.height;\n          }\n        }\n      }\n    };\n    */\n\n    //Swap the depth layer positions of two child sprites\n    o.swapChildren = function(child1, child2) {\n      var index1 = o.children.indexOf(child1),\n        index2 = o.children.indexOf(child2);\n      if (index1 !== -1 && index2 !== -1) {\n\n        //Swap the indexes\n        child1.childIndex = index2;\n        child2.childIndex = index1;\n\n        //Swap the array positions\n        o.children[index1] = child2;\n        o.children[index2] = child1;\n      } else {\n        throw new Error(child + \" Both objects must be a child of the caller \" + o);\n      }\n    }\n\n    //`add` and `remove` convenience methods let you add and remove\n    //many sprites at the same time.\n    o.add = function(spritesToAdd) {\n      var sprites = Array.prototype.slice.call(arguments);\n      if (sprites.length > 1) {\n        sprites.forEach(function(sprite) {\n          o.addChild(sprite);\n        });\n      } else {\n        o.addChild(sprites[0]);\n      }\n    };\n    o.remove = function(spritesToRemove) {\n      var sprites = Array.prototype.slice.call(arguments);\n      if (sprites.length > 1) {\n        sprites.forEach(function(sprite) {\n          o.removeChild(sprite);\n        });\n      } else {\n        o.removeChild(sprites[0]);\n      }\n    };\n\n    //A `setPosition` convenience function to let you set the\n    //x any y position of a sprite with one line of code.\n    o.setPosition = function(x, y) {\n      o.x = x;\n      o.y = y;\n    };\n\n    //The `put` methods are conveniences that help you position a\n    //another sprite in and around this sprite.\n    //First, get a short form reference to the sprite to make the code more\n    //easier to read\n    var a = o;\n\n    //Center a sprite inside this sprite. `xOffset` and `yOffset`\n    //arguments determine by how much the other sprite's position\n    //should be offset from the center. These methods use the\n    //sprites' global coordinates (`gx` and `gy`).\n    //In all these functions, `b` is the second sprite that is being\n    //positioned relative to the first sprite (this one), `a`.\n    //Center `b` inside `a`.\n    o.putCenter = function(b, xOffset, yOffset) {\n      xOffset = xOffset || 0;\n      yOffset = yOffset || 0;\n      b.x = (a.x + a.halfWidth - b.halfWidth) + xOffset;\n      b.y = (a.y + a.halfHeight - b.halfHeight) + yOffset;\n\n      //Compensate for the parent's position\n      o.compensateForParentPosition(a, b);\n    };\n\n    //Position `b` above `a`.\n    o.putTop = function(b, xOffset, yOffset) {\n      xOffset = xOffset || 0;\n      yOffset = yOffset || 0;\n      b.x = (a.x + a.halfWidth - b.halfWidth) + xOffset;\n      b.y = (a.y - b.height) + yOffset;\n\n      //Compensate for the parent's position\n      o.compensateForParentPosition(a, b);\n    };\n\n    //Position `b` to the right of `a`.\n    o.putRight = function(b, xOffset, yOffset) {\n      xOffset = xOffset || 0;\n      yOffset = yOffset || 0;\n      b.x = (a.x + a.width) + xOffset;\n      b.y = (a.y + a.halfHeight - b.halfHeight) + yOffset;\n\n      //Compensate for the parent's position\n      o.compensateForParentPosition(a, b);\n    };\n\n    //Position `b` below `a`.\n    o.putBottom = function(b, xOffset, yOffset) {\n      xOffset = xOffset || 0;\n      yOffset = yOffset || 0;\n      b.x = (a.x + a.halfWidth - b.halfWidth) + xOffset;\n      b.y = (a.y + a.height) + yOffset;\n\n      //Compensate for the parent's position\n      o.compensateForParentPosition(a, b);\n    };\n\n    //Position `b` to the left of `a`.\n    o.putLeft = function(b, xOffset, yOffset) {\n      xOffset = xOffset || 0;\n      yOffset = yOffset || 0;\n      b.x = (a.x - b.width) + xOffset;\n      b.y = (a.y + a.halfHeight - b.halfHeight) + yOffset;\n\n      //Compensate for the parent's position\n      o.compensateForParentPosition(a, b);\n    };\n\n    //`compensateForParentPosition` is a helper funtion for the above\n    //`put` methods that subracts the parent's global position from\n    //the nested child's position.\n    o.compensateForParentPosition = function(a, b) {\n      if(a.parent == b.parent) return;\n      if (b.parent.gx !== 0 || b.parent.gy !== 0) {\n        b.x -= a.gx;\n        b.y -= a.gy;\n      }\n    }\n\n    //Getters and setters for the sprite's internal properties.\n    Object.defineProperties(o, {\n\n      //`gx` and `gy` getters and setters represent the sprite's\n      //global coordinates.\n      gx: {\n        get: function() {\n          if (this.parent) {\n\n            //The sprite's global x position is a combination of\n            //its local x value and its parent's global x value\n            return this.x + this.parent.gx;\n          } else {\n            return this.x;\n          }\n        },\n        enumerable: true,\n        configurable: true\n      },\n      gy: {\n        get: function() {\n          if (this.parent) {\n            return this.y + this.parent.gy;\n          } else {\n            return this.y;\n          }\n        },\n        enumerable: true,\n        configurable: true\n      },\n\n      //A `position` getter. It's a convenience that lets you get and\n      //set the sprite's position as an object with x and y values.\n      position: {\n        get: function() {\n          return {\n            x: o.x,\n            y: o.y\n          };\n        },\n        enumerable: true,\n        configurable: true\n      },\n\n      //An `alpha` getter/setter. The sprite's `alpha` (transparency) should match its\n      //parent's `alpha` value.\n      alpha: {\n        get: function() {\n\n          //Find out the sprite's alpha relative to its parent's alpha\n          var relativeAlpha = o.parent._alpha * o._alpha;\n          return relativeAlpha;\n        },\n        set: function(value) {\n          o._alpha = value;\n        },\n        enumerable: true,\n        configurable: true\n      },\n\n      //The sprite's `halfWidth` and `halfHeight`.\n      halfWidth: {\n        get: function() {\n          return o.width / 2;\n        },\n        enumerable: true,\n        configurable: true\n      },\n      halfHeight: {\n        get: function() {\n          return o.height / 2;\n        },\n        enumerable: true,\n        configurable: true\n      },\n\n      //The sprite's center point.\n      centerX: {\n        get: function() {\n          return o.x + o.halfWidth;\n        },\n        enumerable: true,\n        configurable: true\n      },\n      centerY: {\n        get: function() {\n          return o.y + o.halfHeight;\n        },\n        enumerable: true,\n        configurable: true\n      },\n\n      //The sprite's depth layer. All sprites and groups have their depth layer\n      //set to `0` when their first created. If you want to force a\n      //sprite to appear above another sprite, set its `layer` to a\n      //higher number.\n      layer: {\n        get: function() {\n          return o._layer;\n        },\n        set: function(value) {\n          o._layer = value;\n          o.parent.children.sort(byLayer);\n        },\n        enumerable: true,\n        configurable: true\n      },\n\n      //The `circular` property lets you define whether a sprite\n      //should be interpreted as a circular object. If you set\n      //`circular` to `true`, the sprite is sent to the `makeCircular`\n      //function where its given `radius` and `diameter` properties.\n      circular: {\n        get: function() {\n          return o._circular;\n        },\n        set: function(value) {\n\n          //Give the sprite `diameter` and `radius` properties\n          //if `circular` is `true`.\n          if (value === true && o._circular === false) {\n            makeCircular(o);\n            o._circular = true;\n          }\n\n          //Remove the sprite's `diameter` and `radius` properties\n          //if `circular` is `false`.\n          if (value === false && o._circular === true) {\n            delete o.diameter;\n            delete o.radius;\n            o._circular = false;\n          }\n        },\n        enumerable: true,\n        configurable: true\n      },\n\n      //Is the sprite draggable by the pointer? If `draggable` is set\n      //to `true`, the sprite is added to Ga's `draggableSprites`\n      //array. All the sprites in `draggableSprites` are updated each\n      //frame to check whether they're being dragged.\n      draggable: {\n        get: function() {\n          return o._draggable;\n        },\n        set: function(value) {\n\n          //If it's `true` push the sprite into the `draggableSprites`\n          //array.\n          if (value === true) {\n            ga.draggableSprites.push(o);\n            o._draggable = true;\n\n            //If Ga's `dragAndDrop` property is `false`, set it to\n            //`true`\n            if (ga.dragAndDrop === false) ga.dragAndDrop = true;\n          }\n\n          //If it's `false`, remove it from the `draggableSprites` array.\n          if (value === false) {\n            ga.draggableSprites.splice(ga.draggableSprites.indexOf(o), 1);\n          }\n        },\n        enumerable: true,\n        configurable: true\n      },\n\n      //Is the sprite interactive? If `interactive` is set to `true`,\n      //the sprite is run through the `makeInteractive` method.\n      //`makeInteractive` makes the sprite sensitive to pointer\n      //actions. It also adds the sprite to the Ga's `buttons` array,\n      //which is updated each frame in the `ga.update` method.\n      interactive: {\n        get: function() {\n          return o._interactive;\n        },\n        set: function(value) {\n          if (value === true) {\n\n            //Add interactive properties to the sprite\n            //so that it can act like a button.\n            makeInteractive(o);\n            o._interactive = true;\n          }\n          if (value === false) {\n\n            //Remove the sprite's reference from the game engine's\n            //`buttons` array so that it it's no longer affected\n            //by mouse and touch interactivity.\n            ga.buttons.splice(ga.buttons.indexOf(o), 1);\n            o._interactive = false;\n          }\n        },\n        enumerable: true,\n        configurable: true\n      },\n\n      //The `localBounds` and `globalBounds` methods return an object\n      //with `x`, `y`, `width`, and `height` properties that define\n      //the dimensions and position of the sprite. This is a convenience\n      //to help you set or test boundaries without having to know\n      //these numbers or request them specifically in your code.\n      localBounds: {\n        get: function() {\n          var rectangle = {\n            x: 0,\n            y: 0,\n            width: o.width,\n            height: o.height\n          };\n          return rectangle;\n        },\n        enumerable: true,\n        configurable: true\n      },\n      globalBounds: {\n        get: function() {\n          rectangle = {\n            x: o.gx,\n            y: o.gy,\n            width: o.gx + o.width,\n            height: o.gy + o.height\n          };\n          return rectangle;\n        },\n        enumerable: true,\n        configurable: true\n      },\n\n      //`empty` is a convenience property that will return `true` or\n      //`false` depending on whether or not this sprite's `children`\n      //array is empty.\n      empty: {\n        get: function() {\n          if (o.children.length === 0) {\n            return true;\n          } else {\n            return false;\n          }\n        },\n        enumerable: true,\n        configurable: true\n      }\n    });\n  };\n\n  //### remove\n  //`remove` is a global convenience method that will\n  //remove any sprite, or an argument list of sprites, from its parent.\n  ga.remove = function(spritesToRemove) {\n    var sprites = Array.prototype.slice.call(arguments);\n\n    //Remove sprites that's aren't in an array\n    if (!(sprites[0] instanceof Array)) {\n      if (sprites.length > 1) {\n        sprites.forEach(function(sprite) {\n          sprite.parent.removeChild(sprite);\n        });\n      } else {\n        sprites[0].parent.removeChild(sprites[0]);\n      }\n    }\n\n    //Remove sprites in an array of sprites\n    else {\n      var spritesArray = sprites[0];\n      if (spritesArray.length > 0) {\n        for (var i = spritesArray.length - 1; i >= 0; i--) {\n          var sprite = spritesArray[i];\n          sprite.parent.removeChild(sprite);\n          spritesArray.splice(spritesArray.indexOf(sprite), 1);\n        }\n      }\n    }\n  };\n\n  //### makeCircular\n  //The `makeCircular` function is run whenever a sprite's `circular`\n  //property is set to `true`.\n  //Add `diameter` and `radius` properties to circular sprites.\n  function makeCircular(o) {\n    Object.defineProperties(o, {\n      diameter: {\n        get: function() {\n          return o.width;\n        },\n        set: function(value) {\n          o.width = value;\n          o.height = value;\n        },\n        enumerable: true,\n        configurable: true\n      },\n      radius: {\n        get: function() {\n          return o.width / 2;\n        },\n        set: function(value) {\n          o.width = value * 2;\n          o.height = value * 2;\n        },\n        enumerable: true,\n        configurable: true\n      }\n    });\n  }\n\n  //### makeStage\n  //`makeStage` is called when Ga initializes. It creates a group\n  //object called `stage` which will become the parent of all the other sprites\n  //and groups.\n  function makeStage() {\n    var o = {};\n    makeDisplayObject(o);\n\n    //Flag this as being the `stage` object. There can\n    //only be one stage\n    o.stage = true;\n\n    //Set the stage to the same height and width as the canvas\n    //and position it at the top left corner\n    o.width = ga.canvas.width;\n    o.height = ga.canvas.height;\n    o.x = 0;\n    o.y = 0;\n\n    //The stage has no parent\n    o.parent = undefined;\n    return o;\n  }\n\n  //### group\n  //A `group` is a special kind of display object that doesn't have any\n  //visible content. Instead, you can use it as a parent container to\n  //group other sprites. Supply any number of\n  //sprites to group as arguments, or don't supply any arguments if\n  //you want to create an empty group. (You can always add sprites to\n  //the group later using `addChild`).\n  ga.group = function(spritesToGroup) {\n    var o = {};\n\n    //Make the group a display object.\n    makeDisplayObject(o);\n\n    //Add custom `addChild` and `removeChild` methods that calculate\n    //the size of group based on its contents\n    o.addChild = function(sprite) {\n      if (sprite.parent) {\n        sprite.parent.removeChild(sprite);\n      }\n      sprite.parent = o;\n      o.children.push(sprite);\n      o.calculateSize();\n    };\n    o.removeChild = function(sprite) {\n      if (sprite.parent === o) {\n        o.children.splice(o.children.indexOf(sprite), 1);\n      } else {\n        throw new Error(sprite + \"is not a child of \" + o);\n      }\n      o.calculateSize();\n    };\n\n    //Dynamically calculate the width and height of the sprite based\n    //on the size and position of the children it contains\n    /*\n    o.calculateSize = function() {\n\n      //Calculate the width based on the size of the largest child\n      //that this sprite contains\n      if (o.children.length > 0 && o.stage === false) {\n        for(var i = 0; i < o.children.length - 1; i++) {\n          var child = o.children[i];\n          if (child.x + child.width > o.width) {\n            o.width = child.x + child.width;\n          }\n          if (child.y + child.height > o.height) {\n            o.height = child.y + child.height;\n          }\n        }\n      }\n    };\n    */\n\n    o.calculateSize = function() {\n      //Calculate the width based on the size of the largest child\n      //that this sprite contains\n      if (o.children.length > 0) {\n\n        //Some temporary private variables to help track the new\n        //calculated width and height\n        o._newWidth = 0;\n        o._newHeight = 0;\n\n        //Find the width and height of the child sprites furthest\n        //from the top left corner of the group\n        o.children.forEach(function(child) {\n\n          //Find child sprites that combined x value and width\n          //that's greater than the current value of `_newWidth`\n          if (child.x + child.width > o._newWidth) {\n\n            //The new width is a combination of the child's\n            //x position and its width\n            o._newWidth = child.x + child.width;\n          }\n          if (child.y + child.height > o._newHeight) {\n            o._newHeight = child.y + child.height;\n          }\n        });\n\n        //Apply the `_newWidth` and `_newHeight` to this sprite's width\n        //and height\n        o.width = o._newWidth;\n        o.height = o._newHeight;\n      }\n    };\n\n    //Add the group to the `stage`\n    ga.stage.addChild(o);\n\n    //Group any sprites that were passed to the group's arguments\n    //(Important!: This bit of code needs to happen after adding the group to the stage)\n    if (spritesToGroup) {\n      var sprites = Array.prototype.slice.call(arguments);\n      sprites.forEach(function(sprite) {\n        o.addChild(sprite);\n      });\n    }\n\n    //Return the group\n    return o;\n  };\n\n  //### rectangle\n  //`rectangle` creates and returns a basic rectangular shape.\n  //arguments: width, height, fillColor, borderColor, widthOfBorder,\n  //xPosition, yPosition.\n  ga.rectangle = function(width, height, fillStyle, strokeStyle, lineWidth, x, y) {\n    var o = {};\n\n    //Make this a display object.\n    makeDisplayObject(o);\n\n    //Add a mask property.\n    o.mask = false;\n\n    //Set the defaults.\n    o.width = width || 32;\n    o.height = height || 32;\n    o.fillStyle = fillStyle || \"red\";\n    o.strokeStyle = strokeStyle || \"none\";\n    o.lineWidth = lineWidth || 0;\n    o.x = x || 0;\n    o.y = y || 0;\n\n    //Add the sprite to the stage.\n    ga.stage.addChild(o);\n\n    //Add a `render` method that explains to the canvas how to draw\n    //a rectangle.\n    o.render = function(ctx) {\n      ctx.strokeStyle = o.strokeStyle;\n      ctx.lineWidth = o.lineWidth;\n      ctx.fillStyle = o.fillStyle;\n      ctx.beginPath();\n\n      //Draw the rectangle around the context's center `0` point.\n      ctx.rect(-o.width * o.pivotX, -o.height * o.pivotY,\n        o.width,\n        o.height\n      );\n      if (o.mask === true) {\n        ctx.clip();\n      } else {\n        if (o.strokeStyle !== \"none\") ctx.stroke();\n        if (o.fillStyle !== \"none\") ctx.fill();\n      }\n    };\n\n    //Return the rectangle.\n    return o;\n  };\n\n  //### circle\n  //`circle` returns a basic colored circle.\n  //arguments: diameter, fillColor, outlineColor, borderColor,\n  //xPosition, yPosition\n  ga.circle = function(diameter, fillStyle, strokeStyle, lineWidth, x, y) {\n    var o = {};\n\n    //Make this a display object.\n    makeDisplayObject(o);\n\n    //Add a mask property.\n    o.mask = false;\n\n    //Set the defaults.\n    o.width = diameter || 32;\n    o.height = diameter || 32;\n    o.fillStyle = fillStyle || \"red\";\n    o.strokeStyle = strokeStyle || \"none\";\n    o.lineWidth = lineWidth || \"none\";\n    o.x = x || 0;\n    o.y = y || 0;\n\n    //Add the sprite to the stage.\n    ga.stage.addChild(o);\n\n    //Add `diameter` and `radius` getters and setters.\n    makeCircular(o);\n\n    //Add a `render` method that explains to the canvas how to draw\n    //a circle.\n    o.render = function(ctx) {\n      ctx.strokeStyle = o.strokeStyle;\n      ctx.lineWidth = o.lineWidth;\n      ctx.fillStyle = o.fillStyle;\n      ctx.beginPath();\n      ctx.arc(\n        o.radius + (-o.diameter * o.pivotX),\n        o.radius + (-o.diameter * o.pivotY),\n        o.radius,\n        0, 2 * Math.PI, false\n      );\n      if (o.mask === true) {\n        ctx.clip();\n      } else {\n        if (o.strokeStyle !== \"none\") ctx.stroke();\n        if (o.fillStyle !== \"none\") ctx.fill();\n      }\n    };\n\n    //Return the circle sprite.\n    return o;\n  };\n\n  //### line\n  //`line` creates and returns a line with a start and end points.\n  //arguments: lineColor, lineWidth, startX, startY, endX, endY.\n  ga.line = function(strokeStyle, lineWidth, ax, ay, bx, by) {\n    var o = {};\n\n    //Add basic properties to the sprite.\n    makeDisplayObject(o);\n\n    //Set the defaults.\n    if (!ax && ax !== 0) ax = 0;\n    if (!ay && ay !== 0) ay = 0;\n    if (!bx && bx !== 0) bx = 32;\n    if (!by && by !== 0) by = 32;\n    o.ax = ax;\n    o.ay = ay;\n    o.bx = bx;\n    o.by = by;\n    o.strokeStyle = strokeStyle || \"red\";\n    o.lineWidth = lineWidth || 1;\n\n    //The `lineJoin` style.\n    //Options are \"round\", \"mitre\" and \"bevel\".\n    o.lineJoin = \"round\";\n\n    //Add the sprite to the stage.\n    ga.stage.addChild(o);\n\n    //Add a `render` method that explains to the canvas how to draw\n    //a line.\n    o.render = function(ctx) {\n      ctx.strokeStyle = o.strokeStyle;\n      ctx.lineWidth = o.lineWidth;\n      ctx.lineJoin = o.lineJoin;\n      ctx.beginPath();\n      ctx.moveTo(o.ax, o.ay);\n      ctx.lineTo(o.bx, o.by);\n      //ctx.closePath();\n      if (o.strokeStyle !== \"none\") ctx.stroke();\n      if (o.fillStyle !== \"none\") ctx.fill();\n    };\n\n    //Return the line.\n    return o;\n  };\n\n  //### text\n  //`text` creates and returns a single line of dynamic text.\n  //arguments: stringContent, font, fontColor, xPosition, yPosition.\n  ga.text = function(content, font, fillStyle, x, y) {\n    var o = {};\n\n    //Add the basic sprite properties.\n    makeDisplayObject(o);\n\n    //Set the defaults.\n    o.content = content || \"Hello!\";\n    o.font = font || \"12px sans-serif\";\n    o.fillStyle = fillStyle || \"red\";\n    o.textBaseline = \"top\";\n\n    //Measure the width and height of the text\n    Object.defineProperties(o, {\n      width: {\n        get: function() {\n          return ga.canvas.ctx.measureText(o.content).width;\n        },\n        enumerable: true,\n        configurable: true\n      },\n      height: {\n        get: function() {\n          return ga.canvas.ctx.measureText(\"M\").width;\n        },\n        enumerable: true,\n        configurable: true\n      }\n    });\n\n    //Add the sprite to the stage.\n    ga.stage.addChild(o);\n\n    //Set the object's x and y setters.\n    o.x = x || 0;\n    o.y = y || 0;\n\n    //Add a `render` method that explains to the canvas how to draw text.\n    o.render = function(ctx) {\n      ctx.strokeStyle = o.strokeStyle;\n      ctx.lineWidth = o.lineWidth;\n      ctx.fillStyle = o.fillStyle;\n\n      //Measure the width and height of the text\n      if (o.width === 0) o.width = ctx.measureText(o.content).width;\n      if (o.height === 0) o.height = ctx.measureText(\"M\").width;\n      ctx.translate(-o.width * o.pivotX, -o.height * o.pivotY)\n      ctx.font = o.font;\n      ctx.textBaseline = o.textBaseline;\n      ctx.fillText(\n        o.content,\n        0,\n        0\n      );\n    };\n\n    //Return the text sprite.\n    return o;\n  };\n\n  //### frame\n  //The `frame` method returns and object that defines\n  //in the position and size of a sub-image in a tileset. Use it if you\n  //want to create a sprite from a sub-image inside an Image object.\n  //arguments: sourceString, xPostionOfSubImage, yPositionOfSubImage,\n  //widthOfSubImage, heightOfSubImage.\n  ga.frame = function(source, x, y, width, height) {\n    var o = {};\n    o.image = source;\n    o.x = x;\n    o.y = y;\n    o.width = width;\n    o.height = height;\n    return o;\n  };\n\n  //### frames\n  //The `frames` function returns and object that defines\n  //the position and size of many sub-images in a single tileset image.\n  //arguments: sourceString, 2DArrayOfXandYPositions, widthOfSubImage,\n  //heightOfSubImage.\n  ga.frames = function(source, arrayOfPositions, width, height) {\n    var o = {};\n    o.image = source;\n    o.data = arrayOfPositions;\n    o.width = width;\n    o.height = height;\n    return o;\n  };\n\n  //### filmstrip\n  //If you have a complex animation in a single image, you can use the\n  //`filmstrip` method to automatically create an array of x,y\n  //coordinates for each animation frame.\n  //`filmstrip` arguments:\n  //imageName, frameWidth, frameHeight, spacing\n  //(The last `spacing` argument should be included if there's any\n  //default spacing (padding) around tileset images.)\n  ga.filmstrip = function(imageName, frameWidth, frameHeight, spacing) {\n    var image = ga.assets[imageName].source,\n      positions = [],\n\n      //Find out how many columns and rows there are in the image.\n      columns = image.width / frameWidth,\n      rows = image.height / frameHeight,\n\n      //Find the total number of frames.\n      numberOfFrames = columns * rows;\n\n    for (var i = 0; i < numberOfFrames; i++) {\n\n      //Find the correct row and column for each frame\n      //and figure out its x and y position.\n      var x, y;\n      x = (i % columns) * frameWidth;\n      y = Math.floor(i / columns) * frameHeight;\n\n      //Compensate for any optional spacing (padding) around the tiles if\n      //there is any. This bit of code accumulates the spacing offsets from the\n      //left side of the tileset and adds them to the current tile's position.\n      if (spacing && spacing > 0) {\n        x += spacing + (spacing * i % columns);\n        y += spacing + (spacing * Math.floor(i / columns));\n      }\n\n      //Add the x and y value of each frame to the `positions` array.\n      positions.push([x, y]);\n    }\n\n    //Create and return the animation frames using the `frames` method.\n    return ga.frames(imageName, positions, frameWidth, frameHeight);\n  };\n\n  //### sprite\n  //`sprite` creates and returns a sprite using a JavaScript Image object, a tileset\n  //`frame`, a `filmstrip`, or a frame from a texture atlas (in\n  //standard Texture Packer format).\n  //arguments: sourceString.\n  ga.sprite = function(source) {\n    var o = {};\n\n    //If no `source` is provided, alert the user.\n    if (source === undefined) throw new Error(\"Sprites require a source\");\n\n    //Make this a display object.\n    makeDisplayObject(o);\n    o.frames = [];\n    o.loop = true;\n    o._currentFrame = 0;\n\n    //This next part is complicated. The code has to figure out what\n    //the source is referring to, and then assign its properties\n    //correctly to the sprite's properties. Read carefully!\n    o.setTexture = function(source) {\n      //If the source is just an ordinary string, use it to create the\n      //sprite.\n      if (!source.image) {\n        //If the source isn't an array, then it must be a single image.\n        if (!(source instanceof Array)) {\n          //Is the string referring to a tileset frame from a Texture Packer JSON\n          //file, or is it referring to a JavaScript Image object? Let's find out.\n\n          //No, it's not an Image object. So it must be a tileset frame\n          //from a texture atlas.\n\n          //Use the texture atlas's properties to assign the sprite's\n          //properties.\n          o.tilesetFrame = ga.assets[source];\n          o.source = o.tilesetFrame.source;\n          o.sourceX = o.tilesetFrame.frame.x;\n          o.sourceY = o.tilesetFrame.frame.y;\n          o.width = o.tilesetFrame.frame.w;\n          o.height = o.tilesetFrame.frame.h;\n          o.sourceWidth = o.tilesetFrame.frame.w;\n          o.sourceHeight = o.tilesetFrame.frame.h;\n\n          //The source is an array. But what kind of array? Is it an array\n          //Image objects or an array of texture atlas frame ids?\n        } else {\n          //The source is an array of frames on a texture atlas tileset.\n          o.frames = source;\n          o.source = ga.assets[source[0]].source;\n          o.sourceX = ga.assets[source[0]].frame.x;\n          o.sourceY = ga.assets[source[0]].frame.y;\n          o.width = ga.assets[source[0]].frame.w;\n          o.height = ga.assets[source[0]].frame.h;\n          o.sourceWidth = ga.assets[source[0]].frame.w;\n          o.sourceHeight = ga.assets[source[0]].frame.h;\n        }\n      }\n\n      //If the source contains an `image` sub-property, this must\n      //be a `frame` object that's defining the rectangular area of an inner sub-image\n      //Use that sub-image to make the sprite. If it doesn't contain a\n      //`data` property, then it must be a single frame.\n      else if (source.image && !source.data) {\n        //Throw an error if the source is not an image file.\n        if (!(ga.assets[source.image].source instanceof Image)) {\n          throw new Error(source.image + \" is not an image file\");\n        }\n        o.source = ga.assets[source.image].source;\n        o.sourceX = source.x;\n        o.sourceY = source.y;\n        o.width = source.width;\n        o.height = source.height;\n        o.sourceWidth = source.width;\n        o.sourceHeight = source.height;\n      }\n\n      //If the source contains an `image` sub-property\n      //and a `data` property, then it contains multiple frames\n      else if (source.image && source.data) {\n        o.source = ga.assets[source.image].source;\n        o.frames = source.data;\n\n        //Set the sprite to the first frame\n        o.sourceX = o.frames[0][0];\n        o.sourceY = o.frames[0][1];\n        o.width = source.width;\n        o.height = source.height;\n        o.sourceWidth = source.width;\n        o.sourceHeight = source.height;\n      }\n    };\n\n    //Use `setTexture` to change a sprite's source image\n    //while the game is running\n    o.setTexture(source);\n\n    //Add a `gotoAndStop` method to go to a specific frame.\n    o.gotoAndStop = function(frameNumber) {\n      if (o.frames.length > 0) {\n\n        //If each frame is an array, then the frames were made from an\n        //ordinary Image object using the `frames` method.\n        if (o.frames[0] instanceof Array) {\n          o.sourceX = o.frames[frameNumber][0];\n          o.sourceY = o.frames[frameNumber][1];\n        }\n\n        //If each frame isn't an array, and it has a sub-object called `frame`,\n        //then the frame must be a texture atlas id name.\n        //In that case, get the source position from the `frame` object.\n        else if (ga.assets[o.frames[frameNumber]].frame) {\n          o.source = ga.assets[o.frames[frameNumber]].source;\n          o.sourceX = ga.assets[o.frames[frameNumber]].frame.x;\n          o.sourceY = ga.assets[o.frames[frameNumber]].frame.y;\n          o.sourceWidth = ga.assets[o.frames[frameNumber]].frame.w;\n          o.sourceHeight = ga.assets[o.frames[frameNumber]].frame.h;\n          o.width = ga.assets[o.frames[frameNumber]].frame.w;\n          o.height = ga.assets[o.frames[frameNumber]].frame.h;\n        }\n\n        //Set the `_currentFrame` value.\n        o._currentFrame = frameNumber;\n      } else {\n        throw new Error(\"Frame number \" + frameNumber + \"doesn't exist\");\n      }\n    };\n\n    //Set the sprite's getters\n    o.x = 0;\n    o.y = 0;\n\n    //If the sprite has more than one frame, add a state player\n    if (o.frames.length > 0) {\n      ga.addStatePlayer(o);\n\n      //Add a getter for the `_currentFrames` property.\n      Object.defineProperty(o, \"currentFrame\", {\n        get: function() {\n          return o._currentFrame;\n        },\n        enumerable: false,\n        configurable: false\n      });\n    }\n\n    //Add the sprite to the stage\n    ga.stage.addChild(o);\n\n    //A `render` method that describes how to draw the sprite\n    o.render = function(ctx) {\n      ctx.drawImage(\n        o.source,\n        o.sourceX, o.sourceY,\n        o.sourceWidth, o.sourceHeight, -o.width * o.pivotX, -o.height * o.pivotY,\n        o.width, o.height\n      );\n    };\n\n    //Return the sprite\n    return o;\n  };\n\n  //### button\n  //`button` creates and returns a button with `up`, `over` and `down`\n  //states. You can also assign custom `press` and `release` methods.\n  //arguments: sourceString (The same as an ordinary sprite.)\n  ga.button = function(source) {\n\n    //First, make an ordinary sprite.\n    var o = ga.sprite(source);\n\n    //Assign this as a \"button\" subtype.\n    o.subtype = \"button\";\n\n    //Make it interactive (see ahead).\n    makeInteractive(o);\n\n    //Return it.\n    return o;\n  };\n\n  //### makeInteractive\n  //The `makeInteractive` function lets you assign `press`, `release`, `over`, `tap`\n  //and `out` actions to sprites.\n  //Also tells you the pointer's state of interaction with the sprite.\n  //`makeInteractive` is called on a sprite when a sprite's\n  //`interactive` property is set to `true`.\n  function makeInteractive(o) {\n\n    //The `press` and `release` methods. They're `undefined`\n    //for now, but they'll be defined in the game program.\n    o.press = o.press || undefined;\n    o.release = o.release || undefined;\n    o.over = o.over || undefined;\n    o.out = o.out || undefined;\n    o.tap = o.tap || undefined;\n\n    //The `state` property tells you button's\n    //current state. Set its initial state to \"up\".\n    o.state = \"up\";\n\n    //The `action` property tells you whether its being pressed or\n    //released.\n    o.action = \"\";\n\n    //`pressed` is a Boolean that helps track whether or not\n    //the button has been pressed down.\n    o.pressed = false;\n\n    //`enabled` is a Boolean which, if false, deactivates the button.\n    o.enabled = true;\n\n    //`hoverOver` is a Boolean which checkes whether the pointer\n    //has hovered over the button.\n    o.hoverOver = false;\n\n    //Add the button into the global `buttons` array so that it\n    //can be updated by the game engine.\n    ga.buttons.push(o);\n\n    //The `update` method will be called each frame inside\n    //Ga's game loop.\n    o.update = function(pointer, canvas) {\n\n      //Only update the button if it's enabled.\n      if (o.enabled) {\n\n        //Figure out if the pointer is touching the button.\n        var hit = ga.pointer.hitTestSprite(o);\n\n        //1. Figure out the current state.\n        if (pointer.isUp) {\n\n          //Up state.\n          o.state = \"up\";\n\n          //Show the first frame, if this is a button.\n          if (o.subtype === \"button\") o.show(0);\n        }\n\n        //If the pointer is touching the button, figure out\n        //if the over or down state should be displayed.\n        if (hit) {\n\n          //Over state.\n          o.state = \"over\";\n\n          //Show the second frame if this sprite has\n          //3 frames and it's button.\n          if (o.frames && o.frames.length === 3 && o.subtype === \"button\") {\n            o.show(1);\n          }\n\n          //Down state.\n          if (pointer.isDown) {\n            o.state = \"down\";\n\n            //Show the third frame if this sprite is a button and it\n            //has only three frames, or show the second frame if it\n            //only has two frames.\n            if (o.subtype === \"button\") {\n              if (o.frames.length === 3) {\n                o.show(2);\n              } else {\n                o.show(1);\n              }\n            }\n          }\n        }\n\n        //Run the correct button action.\n        //a. Run the `press` method if the button state is \"down\" and\n        //the button hasn't already been pressed.\n        if (o.state === \"down\") {\n          if (!o.pressed) {\n            if (o.press) o.press();\n            o.pressed = true;\n            o.action = \"pressed\";\n          }\n        }\n\n        //b. Run the `release` method if the button state is \"over\" and\n        //the button has been pressed.\n        if (o.state === \"over\") {\n          if (o.pressed) {\n            if (o.release) o.release();\n            o.pressed = false;\n            o.action = \"released\";\n\n            //If the pointer was tapped and the user assigned a `tap`\n            //method, call the `tap` method\n            if (ga.pointer.tapped && o.tap) o.tap();\n          }\n\n          //Run the `over` method if it has been assigned\n          if (!o.hoverOver) {\n            if (o.over) o.over();\n            o.hoverOver = true;\n          }\n        }\n\n        //c. Check whether the pointer has been released outside\n        //the button's area. If the button state is \"up\" and it's\n        //already been pressed, then run the `release` method.\n        if (o.state === \"up\") {\n          if (o.pressed) {\n            if (o.release) o.release();\n            o.pressed = false;\n            o.action = \"released\";\n          }\n\n          //Run the `out` method if it has been assigned\n          if (o.hoverOver) {\n            if (o.out) o.out();\n            o.hoverOver = false;\n          }\n        }\n      }\n    };\n  }\n\n  //A convenience method that lets you access Images by their file names.\n  ga.image = function(imageFileName) {\n    return ga.assets[imageFileName];\n  };\n\n  //A convenience method that lets you access JSON files by their file names.\n  ga.json = function(jsonFileName) {\n    return ga.assets[jsonFileName];\n  };\n\n  //### addStatePlayer\n  //`addStatePlayer` adds a state manager and keyframe animation player for\n  //sprites with more than one frame. Its called automatically when\n  //`sprite`s are created.\n  ga.addStatePlayer = function(sprite) {\n    var frameCounter = 0,\n      numberOfFrames = 0,\n      startFrame = 0,\n      endFrame = 0,\n      timerInterval = undefined,\n      playing = false;\n\n    //The `show` function (to display static states.)\n    function show(frameNumber) {\n\n      //Reset any possible previous animations.\n      reset();\n\n      //Find the new state on the sprite.\n      //If `frameNumber` is a number, use that number to go to the\n      //correct frame.\n      if (typeof frameNumber !== \"string\") {\n        sprite.gotoAndStop(frameNumber);\n      }\n\n      //If `frameNumber` is string that describes a sprite's frame id,\n      //then go to the index number that matches that id name.\n      else {\n        sprite.gotoAndStop(sprite.frames.indexOf(frameNumber));\n      }\n    }\n\n    //The `play` function plays all the sprites frames.\n    function play() {\n      playSequence([0, sprite.frames.length - 1]);\n    }\n\n    //The `stop` function stops the animation at the current frame.\n    function stop() {\n      reset();\n      sprite.gotoAndStop(sprite.currentFrame);\n    }\n\n    //The `playSequence` function, to play a sequence of frames.\n    function playSequence(sequenceArray) {\n\n      //Reset any possible previous animations.\n      reset();\n\n      //Figure out how many frames there are in the range.\n      startFrame = sequenceArray[0];\n      endFrame = sequenceArray[1];\n      numberOfFrames = endFrame - startFrame;\n\n      //Compensate for two edge cases:\n      //1. if the `startFrame` happens to be `0`.\n      if (startFrame === 0) {\n        numberOfFrames += 1;\n        frameCounter += 1;\n      }\n\n      //2. if only a two-frame sequence was provided.\n      if (numberOfFrames === 1) {\n        numberOfFrames = 2;\n        frameCounter += 1;\n      };\n\n      //Calculate the frame rate. Set a default fps of 12.\n      if (!sprite.fps) sprite.fps = 12;\n      var frameRate = 1000 / sprite.fps;\n\n      //Set the sprite to the starting frame.\n      sprite.gotoAndStop(startFrame);\n\n      //If the state isn't already playing, start it.\n      if (!playing) {\n        timerInterval = setInterval(advanceFrame.bind(this), frameRate);\n        playing = true;\n      }\n    }\n\n    //`advanceFrame` is called by `setInterval` to display the next frame\n    //in the sequence based on the `frameRate`. When frame sequence\n    //reaches the end, it will either stop it or loop it.\n    function advanceFrame() {\n\n      //Advance the frame if `frameCounter` is less than\n      //the state's total frames.\n      if (frameCounter < numberOfFrames) {\n\n        //Advance the frame.\n        sprite.gotoAndStop(sprite.currentFrame + 1);\n\n        //Update the frame counter.\n        frameCounter += 1;\n      } else {\n\n        //If we've reached the last frame and `loop`\n        //is `true`, then start from the first frame again.\n        if (sprite.loop) {\n          sprite.gotoAndStop(startFrame);\n          frameCounter = 1;\n        }\n      }\n    }\n\n    function reset() {\n\n      //Reset `playing` to `false`, set the `frameCounter` to 0,\n      //and clear the `timerInterval`.\n      if (timerInterval !== undefined && playing === true) {\n        playing = false;\n        frameCounter = 0;\n        startFrame = 0;\n        endFrame = 0;\n        numberOfFrames = 0;\n        clearInterval(timerInterval);\n      }\n    }\n\n    //Add the `show`, `play`, `playing`, `stop` and `playSequence` methods to the sprite.\n    sprite.show = show;\n    sprite.play = play;\n    sprite.stop = stop;\n    sprite.playing = playing;\n    sprite.playSequence = playSequence;\n  };\n\n\n  /*\n  Rendering\n  -------\n\n  The render method that displays all the sprites on the canvas.\n  Ga uses it inside the game loop to render the sprites like this:\n\n      ga.render(canvasContext);\n\n  */\n\n  ga.render = function(canvas, lagOffset) {\n\n    //Get a reference to the context.\n    var ctx = canvas.ctx;\n\n    //Clear the canvas.\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    //Display the all the sprites.\n    for (var i = 0; i < ga.stage.children.length; i++) {\n      var sprite = ga.stage.children[i];\n\n      //Only draw sprites if they're visible and inside the\n      //area of the canvas.\n      displaySprite(sprite);\n    }\n\n    function displaySprite(sprite) {\n      if (\n        sprite.visible && sprite.gx < canvas.width + sprite.width && sprite.gx + sprite.width >= -sprite.width && sprite.gy < canvas.height + sprite.height && sprite.gy + sprite.height >= -sprite.height\n      ) {\n\n        //Save the current context state.\n        ctx.save();\n\n        //ctx.setTransform(1,0,0,1,0,0);\n        //Calculate the sprites' interpolated render positions if\n        //`ga.interpolate` is `true` (It is true by default)\n        if (ga.interpolate) {\n          if (sprite._previousX !== undefined) {\n            sprite.renderX = (sprite.x - sprite._previousX) * lagOffset + sprite._previousX;\n          } else {\n            sprite.renderX = sprite.x;\n          }\n          if (sprite._previousY !== undefined) {\n            sprite.renderY = (sprite.y - sprite._previousY) * lagOffset + sprite._previousY;\n          } else {\n            sprite.renderY = sprite.y;\n          }\n        } else {\n          sprite.renderX = sprite.x;\n          sprite.renderY = sprite.y;\n        }\n\n        //Draw the sprite\n        ctx.translate(\n          sprite.renderX + (sprite.width * sprite.pivotX),\n          sprite.renderY + (sprite.height * sprite.pivotY)\n        );\n        /*\n        var cos = Math.cos(sprite.rotation),\n            sin = Math.sin(sprite.rotation),\n            scaleX = sprite.scaleX,\n            scaleY = sprite.scaleY,\n            translateX = sprite.renderX + (sprite.width * sprite.pivotX),\n            translateY = sprite.renderY + (sprite.height * sprite.pivotY);\n\n        ctx.setTransform(\n          scaleX + cos,\n          sin, -sin,\n          scaleY - cos,\n          translateX,\n          translateY\n        );\n        */\n        //(scaleX+cos, skewX+sin, skewY-sin, scaleY-cos, translateX, translateY);\n\n        //Set the alpha\n        ctx.globalAlpha = sprite.alpha;\n\n        //Rotate the sprite using its `rotation` value.\n        ctx.rotate(sprite.rotation);\n\n        //Scale the sprite using its `scaleX` and scaleY` properties.\n        ctx.scale(sprite.scaleX, sprite.scaleY);\n\n        //Add a shadow if the sprite's `shadow` property is `true`.\n        if (sprite.shadow) {\n          ctx.shadowColor = sprite.shadowColor;\n          ctx.shadowOffsetX = sprite.shadowOffsetX;\n          ctx.shadowOffsetY = sprite.shadowOffsetY;\n          ctx.shadowBlur = sprite.shadowBlur;\n        }\n\n        //Add an optional blend mode\n        if (sprite.blendMode) ctx.globalCompositeOperation = sprite.blendMode;\n\n        //Use the sprite's custom `render` method to figure out how to\n        //draw the sprite. This is only run if the sprite actually has\n        //a `render` method. Most do, but `group` sprites don't and\n        //neither does the `stage` object.\n        if (sprite.render) sprite.render(ctx);\n\n        //If the sprite contains child sprites in its\n        //`children` array, display them by calling this very same\n        //`displaySprite` function again.\n        if (sprite.children && sprite.children.length > 0) {\n\n          //Reset the context back to the parent sprite's top left corner\n          ctx.translate(-sprite.width * sprite.pivotX, -sprite.height * sprite.pivotY);\n          /*\n        ctx.setTransform(\n          -scaleX - cos,\n          -sin, sin,\n          -scaleY + cos,\n          -translateX,\n          -translateY\n        );\n        */\n          for (var j = 0; j < sprite.children.length; j++) {\n\n            //Find the sprite's child\n            var child = sprite.children[j];\n\n            //display the child\n            displaySprite(child);\n          }\n        }\n\n        //The context's original position will only be restored after\n        //the child sprites have been rendered. This is why the children have\n        //the same rotation and alpha as the parents.\n        ctx.restore();\n        //ctx.setTransform(1,0,0,1,0,0);\n      }\n    }\n  }\n\n  /*\n  Chapter 4: Ga's helper objects and methods\n  ------------------------------------------\n  */\n\n  //### asset\n  //All the game engine's assets are stored in this object and it has\n  //a `load` method that manages asset loading. You can load assets at\n  //any time during the game by using the `asset.load` method.\n  ga.assets = {\n\n    //Properties to help track the assets being loaded.\n    toLoad: 0,\n    loaded: 0,\n\n    //File extensions for different types of assets.\n    imageExtensions: [\"png\", \"jpg\", \"gif\", \"webp\"],\n    fontExtensions: [\"ttf\", \"otf\", \"ttc\", \"woff\"],\n    audioExtensions: [\"mp3\", \"ogg\", \"wav\", \"webm\"],\n    jsonExtensions: [\"json\"],\n\n    //The callback function that should run when all assets have loaded.\n    //Assign this when you load the fonts, like this: `assets.whenLoaded = makeSprites;`.\n    whenLoaded: undefined,\n\n    //The load method creates and loads all the assets. Use it like this:\n    //`assets.load([\"images/anyImage.png\", \"fonts/anyFont.otf\"]);`.\n\n    load: function(sources) {\n      console.log(\"Loading assets...\");\n\n      //Get a reference to this asset object so we can\n      //refer to it in the `forEach` loop ahead.\n      var self = this;\n\n      //Find the number of files that need to be loaded.\n      self.toLoad = sources.length;\n      sources.forEach(function(source) {\n\n        //Find the file extension of the asset.\n        var extension = source.split('.').pop();\n\n        //#### Images\n        //Load images that have file extensions that match\n        //the `imageExtensions` array.\n        if (self.imageExtensions.indexOf(extension) !== -1) {\n\n          //Create a new image and add a loadHandler\n          var image = new Image();\n          image.addEventListener(\"load\", function() {\n            //Get the image file name.\n            image.name = source;\n            self[image.name] = {\n              //If you just want the file name and the extension, you can\n              //get it like this:\n              //image.name = source.split(\"/\").pop();\n              //Assign the image as a property of the assets object so\n              //we can access it like this: `assets[\"images/imageName.png\"]`.\n              source: image,\n              frame: {\n                x: 0,\n                y: 0,\n                w: image.width,\n                h: image.height\n              }\n            };\n            self.loadHandler();\n          }, false);\n\n          //Set the image's src property so we can start loading the image.\n          image.src = source;\n        }\n\n        //#### Fonts\n        //Load fonts that have file extensions that match the `fontExtensions` array.\n        else if (self.fontExtensions.indexOf(extension) !== -1) {\n\n          //Use the font's file name as the `fontFamily` name.\n          var fontFamily = source.split(\"/\").pop().split(\".\")[0];\n\n          //Append an `@afont-face` style rule to the head of the HTML\n          //document. It's kind of a hack, but until HTML5 has a\n          //proper font loading API, it will do for now.\n          var newStyle = document.createElement('style');\n          var fontFace = \"@font-face {font-family: '\" + fontFamily + \"'; src: url('\" + source + \"');}\";\n          newStyle.appendChild(document.createTextNode(fontFace));\n          document.head.appendChild(newStyle);\n\n          //Tell the loadHandler we're loading a font.\n          self.loadHandler();\n        }\n\n        //#### Sounds\n        //Load audio files that have file extensions that match\n        //the `audioExtensions` array.\n        else if (self.audioExtensions.indexOf(extension) !== -1) {\n          //Create a sound sprite.\n          //\n          var soundSprite = ga.makeSound(source, self.loadHandler.bind(self));\n\n          //Get the sound file name.\n          soundSprite.name = source;\n\n          //If you just want to extract the file name with the\n          //extension, you can do it like this:\n          //soundSprite.name = source.split(\"/\").pop();\n          //Assign the sound as a property of the assets object so\n          //we can access it like this: `assets[\"sounds/sound.mp3\"]`.\n          self[soundSprite.name] = soundSprite;\n        }\n\n        //#### JSON\n        //Load JSON files that have file extensions that match\n        //the `jsonExtensions` array.\n        else if (self.jsonExtensions.indexOf(extension) !== -1) {\n\n          //Create a new `xhr` object and an object to store the file.\n          var xhr = new XMLHttpRequest();\n          var file = {};\n\n          //Use xhr to load the JSON file.\n          xhr.open(\"GET\", source, true);\n          xhr.addEventListener(\"readystatechange\", function() {\n\n            //Check to make sure the file has loaded properly.\n            if (xhr.status === 200 && xhr.readyState === 4) {\n\n              //Convert the JSON data file into an ordinary object.\n              file = JSON.parse(xhr.responseText);\n\n              //Get the file name.\n              file.name = source;\n\n              //Assign the file as a property of the assets object so\n              //we can access it like this: `assets[\"file.json\"]`.\n              self[file.name] = file;\n\n              //Texture Packer support.\n              //If the file has a `frames` property then its in Texture\n              //Packer format.\n              if (file.frames) {\n\n                //Create the tileset frames.\n                self.createTilesetFrames(file, source);\n              } else {\n\n                //Alert the load handler that the file has loaded.\n                self.loadHandler();\n              }\n            }\n          });\n\n          //Send the request to load the file.\n          xhr.send();\n        }\n\n        //Display a message if a file type isn't recognized.\n        else {\n          console.log(\"File type not recognized: \" + source);\n        }\n      });\n    },\n\n    //#### createTilesetFrames\n    //`createTilesetFrames` parses the JSON file  texture atlas and loads the frames\n    //into this `assets` object.\n    createTilesetFrames: function(json, source) {\n      var self = this;\n\n      //Get the image's file path.\n      var baseUrl = source.replace(/[^\\/]*$/, '');\n      var image = new Image();\n      image.addEventListener(\"load\", loadImage, false);\n      image.src = baseUrl + json.meta.image;\n\n      function loadImage() {\n\n        //Assign the image as a property of the `assets` object so\n        //we can access it like this:\n        //`assets[\"images/imageName.png\"]`.\n        self[baseUrl + json.meta.image] = {\n          source: image,\n          frame: {\n            x: 0,\n            y: 0,\n            w: image.width,\n            h: image.height\n          }\n        };\n\n        //Loop through all the frames.\n        Object.keys(json.frames).forEach(function(tilesetImage) {\n\n          //console.log(json.frames[image].frame);\n          //The `frame` object contains all the size and position\n          //data.\n          //Add the frame to the asset object so that we\n          //can access it like this: `assets[\"frameName.png\"]`.\n          self[tilesetImage] = json.frames[tilesetImage];\n\n          //Get a reference to the source so that it will be easy for\n          //us to access it later.\n          self[tilesetImage].source = image;\n          //console.log(self[tilesetImage].source)\n        });\n\n        //Alert the load handler that the file has loaded.\n        self.loadHandler();\n      }\n    },\n\n    //#### loadHandler\n    //The `loadHandler` will be called each time an asset finishes loading.\n    loadHandler: function() {\n      var self = this;\n      self.loaded += 1;\n      console.log(self.loaded);\n\n      //Check whether everything has loaded.\n      if (self.toLoad === self.loaded) {\n\n        //If it has, run the callback function that was assigned to the `whenLoaded` property\n\n        //Reset `loaded` and `toLoaded` so we can load more assets\n        //later if we want to.\n        self.toLoad = 0;\n        self.loaded = 0;\n        self.whenLoaded();\n      }\n    }\n  };\n\n  //### makePointer\n  //Makes a pointer object that unifies touch and mouse interactivity.\n  //The pointer has `x` and `y` properties and `isUp`, `isDown` and\n  //`tapped` Boolean states.\n  function makePointer() {\n    var o = {};\n    o._x = 0;\n    o._y = 0;\n\n    //Add `centerX` and `centerY` getters so that we\n    //can use the pointer's coordinates with easing\n    //and collision functions.\n    Object.defineProperties(o, {\n      x: {\n        get: function() {\n          return o._x / ga.scale;\n        },\n        enumerable: true,\n        configurable: true\n      },\n      y: {\n        get: function() {\n          return o._y / ga.scale;\n        },\n        enumerable: true,\n        configurable: true\n      },\n      centerX: {\n        get: function() {\n          return o.x;\n        },\n        enumerable: true,\n        configurable: true\n      },\n      centerY: {\n        get: function() {\n          return o.y;\n        },\n        enumerable: true,\n        configurable: true\n      },\n      //`position` returns an object with x and y properties that\n      //contain the pointer's position.\n      position: {\n        get: function() {\n          return {\n            x: o.x,\n            y: o.y\n          };\n        },\n        enumerable: true,\n        configurable: true\n      }\n    });\n\n    //Booleans to track the pointer state.\n    o.isDown = false;\n    o.isUp = true;\n    o.tapped = false;\n\n    //Properties to help measure the time between up and down states.\n    o.downTime = 0;\n    o.elapsedTime = 0;\n\n    //Optional, user-definable `press`, `release`, and `tap` methods\n    o.press = undefined;\n    o.release = undefined;\n    o.tap = undefined;\n\n    //A `dragSprite` property to help with drag and drop.\n    o.dragSprite = null;\n\n    //The drag offsets to help drag sprites.\n    o.dragOffsetX = 0;\n    o.dragOffsetY = 0;\n\n\n    //The pointer's mouse `moveHandler`\n    o.moveHandler = function(event) {\n\n      //Find the pointer’s x and y position (for mouse).\n      //Subtract the element's top and left offset from the browser window.\n      o._x = (event.pageX - event.target.offsetLeft);\n      o._y = (event.pageY - event.target.offsetTop);\n\n      //Prevent the canvas from being selected.\n      event.preventDefault();\n    };\n\n    //The pointer's `touchmoveHandler`.\n    o.touchmoveHandler = function(event) {\n\n      //Find the touch point's x and y position.\n      o._x = (event.targetTouches[0].pageX - ga.canvas.offsetLeft);\n      o._y = (event.targetTouches[0].pageY - ga.canvas.offsetTop);\n\n      //Prevent the canvas from being selected.\n      event.preventDefault();\n    };\n\n    //The pointer's `downHandler`.\n    o.downHandler = function(event) {\n\n      //Find the pointer’s x and y position (for mouse).\n      o._x = (event.pageX - event.target.offsetLeft);\n      o._y = (event.pageY - event.target.offsetTop);\n\n      //Set the down states.\n      o.isDown = true;\n      o.isUp = false;\n      o.tapped = false;\n\n      //Capture the current time.\n      o.downTime = Date.now();\n\n      //Call the `press` method if it's been assigned by the user\n      if (o.press) o.press();\n\n      //Prevent the canvas from being selected.\n      event.preventDefault();\n    };\n\n    //The pointer's `touchstartHandler`.\n    o.touchstartHandler = function(event) {\n\n      //Find the touch point's x and y position.\n      o._x = event.targetTouches[0].pageX - ga.canvas.offsetLeft;\n      o._y = event.targetTouches[0].pageY - ga.canvas.offsetTop;\n\n      //Set the down states.\n      o.isDown = true;\n      o.isUp = false;\n      o.tapped = false;\n\n      //Capture the current time.\n      o.downTime = Date.now();\n\n      //Call the `press` method if it's been assigned by the user.\n      if (o.press) o.press();\n\n      //Prevent the canvas from being selected.\n      event.preventDefault();\n    };\n\n    //The pointer's `upHandler`.\n    o.upHandler = function(event) {\n\n      //Figure out how much time the pointer has been down.\n      o.elapsedTime = Math.abs(o.downTime - Date.now());\n\n      //If it's less than 200 milliseconds, it must be a tap or click.\n      if (o.elapsedTime <= 200) {\n        o.tapped = true;\n\n        //Call the `tapped` method if it's been assigned by the user.\n        if (o.tap) o.tap();\n      }\n      o.isUp = true;\n      o.isDown = false;\n\n      //Call the `release` method if it's been assigned by the user.\n      if (o.release) o.release();\n\n      //Prevent the canvas from being selected.\n      event.preventDefault();\n    };\n\n    //Bind the events to the handlers.\n    //Mouse events.\n    ga.canvas.addEventListener(\n      \"mousemove\", o.moveHandler.bind(o), false\n    );\n    ga.canvas.addEventListener(\n      \"mousedown\", o.downHandler.bind(o), false\n    );\n\n    //Add a `mouseup` event to the `window` object as well to\n    //catch a mouse button release outside of the canvas area.\n    ga.canvas.addEventListener(\n      \"mouseup\", o.upHandler.bind(o), false\n    );\n\n    //Touch events.\n    ga.canvas.addEventListener(\n      \"touchmove\", o.touchmoveHandler.bind(o), false\n    );\n    ga.canvas.addEventListener(\n      \"touchstart\", o.touchstartHandler.bind(o), false\n    );\n\n    //Add a `touchend` event to the `window` object as well to\n    //catch a mouse button release outside of the canvas area.\n    ga.canvas.addEventListener(\n      \"touchend\", o.upHandler.bind(o), false\n    );\n\n    //Disable the default pan and zoom actions on the `canvas`.\n    ga.canvas.style.touchAction = \"none\";\n\n    //`hitTestSprite` figures out if the pointer is touching a sprite.\n    o.hitTestSprite = function(sprite) {\n      var hit = false;\n\n      //Is the sprite rectangular?\n      if (!sprite.circular) {\n\n        //Get the position of the sprite's edges using global\n        //coordinates.\n        var left = sprite.gx, // * ga.scale,\n          right = (sprite.gx + sprite.width), // * ga.scale,\n          top = sprite.gy, // * ga.scale,\n          bottom = (sprite.gy + sprite.height), // * ga.scale;\n\n          //Find out if the point is intersecting the rectangle.\n          hit = o.x > left && o.x < right && o.y > top && o.y < bottom;\n      }\n\n      //Is the sprite circular?\n      else {\n\n        //Find the distance between the point and the\n        //center of the circle.\n        var vx = o.x - ((sprite.gx + sprite.halfWidth)), // * ga.scale),\n          vy = o.y - ((sprite.gy + sprite.halfHeight)), // * ga.scale),\n          magnitude = Math.sqrt(vx * vx + vy * vy);\n\n        //The point is intersecting the circle if the magnitude\n        //(distance) is less than the circle's radius.\n        hit = magnitude < sprite.radius;\n      }\n      return hit;\n    };\n\n    o.updateDragAndDrop = function() {\n      if (o.isDown) {\n\n        //Capture the co-ordinates at which the pointer was\n        //pressed down and find out if it's touching a sprite.\n        if (o.dragSprite === null) {\n\n          //Loop through the draggable sprites in reverse to start searching at the bottom of the stack.\n          for (var i = ga.draggableSprites.length - 1; i > -1; i--) {\n            var sprite = ga.draggableSprites[i];\n\n            //Check for a collision with the pointer using `hitTestPoint`.\n            if (sprite.draggable && o.hitTestSprite(sprite)) {\n\n              //Calculate the difference between the pointer's\n              //position and the sprite's position.\n              o.dragOffsetX = o.x - sprite.gx;\n              o.dragOffsetY = o.y - sprite.gy;\n\n              //Set the sprite as the pointer's `dragSprite` property.\n              o.dragSprite = sprite;\n\n              //The next two lines re-order the `sprites` array so that the\n              //selected sprite is displayed above all the others.\n              //First, splice the sprite out of its current position in\n              //its parent's `children` array.\n              var children = sprite.parent.children;\n              children.splice(children.indexOf(sprite), 1);\n\n              //Next, push the `dragSprite` to the end of its `children` array so that it's\n              //displayed last, above all the other sprites.\n              children.push(sprite);\n\n              //Reorganize the `draggableSpites` array in the same way\n              ga.draggableSprites.splice(ga.draggableSprites.indexOf(sprite), 1);\n              ga.draggableSprites.push(sprite);\n              break;\n            }\n          }\n        } else {\n\n          //If the pointer is down and it has a `dragSprite`, make the sprite follow the pointer's\n          //position, with the calculated offset.\n          o.dragSprite.x = o.x - o.dragOffsetX;\n          o.dragSprite.y = o.y - o.dragOffsetY;\n        }\n      }\n\n      //If the pointer is up, drop the `dragSprite` by setting it to `null`.\n      if (o.isUp) {\n        o.dragSprite = null;\n      }\n\n      //Change the mouse arrow pointer to a hand if it's over a\n      //sprite.\n      ga.draggableSprites.some(function(sprite) {\n        if (sprite.draggable && o.hitTestSprite(sprite)) {\n          ga.canvas.style.cursor = \"pointer\";\n          return true;\n        } else {\n          ga.canvas.style.cursor = \"auto\";\n          return false;\n        }\n      });\n    }\n\n    //Return the pointer.\n    return o;\n  }\n\n  /*\n  ### keyboard\n  The `keyboard` function creates `key` objects\n  that listen for keyboard events. Create a new key object like\n  this:\n\n     var keyObject = g.keyboard(asciiKeyCodeNumber);\n\n  Then assign `press` and `release` methods like this:\n\n    keyObject.press = function() {\n      //key object pressed\n    };\n    keyObject.release = function() {\n      //key object released\n    };\n\n  Keyboard objects also have `isDown` and `isUp` Booleans that you can check.\n  */\n\n  function keyboard(keyCode) {\n    var key = {};\n    key.code = keyCode;\n    key.isDown = false;\n    key.isUp = true;\n    key.press = undefined;\n    key.release = undefined;\n\n    //The `downHandler`\n    key.downHandler = function(event) {\n      if (event.keyCode === key.code) {\n        if (key.isUp && key.press) key.press();\n        key.isDown = true;\n        key.isUp = false;\n      }\n      event.preventDefault();\n    };\n\n    //The `upHandler`\n    key.upHandler = function(event) {\n      if (event.keyCode === key.code) {\n        if (key.isDown && key.release) key.release();\n        key.isDown = false;\n        key.isUp = true;\n      }\n      event.preventDefault();\n    };\n\n    //Attach event listeners\n    ga.canvas.addEventListener(\n      \"keydown\", key.downHandler.bind(key), false\n    );\n    ga.canvas.addEventListener(\n      \"keyup\", key.upHandler.bind(key), false\n    );\n    return key;\n  }\n\n  /*\n  ### makeKeys\n  `makeKeys` is called when Ga is initialized. It pre-defines the\n  arrow keys and space bar so that you can use them right away in\n  your games like this:\n\n      g.key.leftArrow.press = function() {\n        //left arrow pressed.\n      };\n      g.key.leftArrow.release = function() {\n        //left arrow released.\n      };\n\n  The keyboard objects that `makeKeys` creates are:\n\n      key.leftArrow\n      key.upArrow\n      key.rightArrow\n      key.downArrow\n      key.space\n\n  */\n\n  function makeKeys() {\n    var o = {};\n    //Assign the arrow keys and the space bar\n    o.leftArrow = keyboard(37);\n    o.upArrow = keyboard(38);\n    o.rightArrow = keyboard(39);\n    o.downArrow = keyboard(40);\n    o.space = keyboard(32);\n    return o;\n  }\n\n  //### byLayer\n  //`byLayer` is an array sort method that's called when a sprite's\n  //`layer` property is changed.\n  function byLayer(a, b) {\n\n    //return a.layer - b.layer;\n    if (a.layer < b.layer) {\n      return -1;\n    } else if (a.layer > b.layer) {\n      return 1;\n    } else {\n      return 1;\n    }\n  }\n\n  //Make the `keyboard` and `makeDisplayObject` functions public.\n  ga.keyboard = keyboard;\n  ga.makeDisplayObject = makeDisplayObject;\n\n  //Initialize the plugins, if they exist.\n  if (GA.plugins !== undefined) GA.plugins(ga);\n\n  //Install any user-defined plugins or custom initialization code.\n  if (GA.custom !== undefined) GA.custom(ga);\n\n  //Return `ga`.\n  return ga;\n};\n\n//### ga\n//The `ga` convenience function is just a nice quick way to create an\n//instance of Ga without having the call `Ga.create()` It's really not\n//necessary, but I like it!\nwindow.ga = GA.create;\n","// player.vy = 0;\n// ==ClosureCompiler==\n// @output_file_name default.js\n// @compilation_level SIMPLE_OPTIMIZATIONS\n// @language ECMASCRIPT5\n// @fileoverview\n// @suppress {checkTypes | globalThis | checkVars}\n// ==/ClosureCompiler==\n\n/*\nGa plugins\n==========\nWeclome to the `plugins.js` file!\nThis file contains lots of extra tools that are really useful for making games,\nbut which are more specialized that than the universal tools in `ga.js` file.\n\nHow can use these plugins? The easiest way is just to link this entire file\nwith a `<script>` tag. Then you have immediate access to all this code\nand you can decide later what you really need.\n\nYour own custom plugins\n-----------------------\n\nIf you wan to keep you game file size small, create\nyour own custom plugins file. Here's how:\n\n1. Make a new JS file called `custom.js` (or an other name you want to give it.)\n2. Add this:\n\n    GA.custom = function(ga) {\n      //Your own collection of plugins will go here\n    };\n\n3. Link `custom.js` to your game's main HTML document with a `<script>` tag.\n\n4. Then just copy/paste any plugin functions from this\nfile (`plugins.js`) into your own `custom.js` file. Like this:\n\n    GA.custom = function(ga) {\n      //Create a random number within a specific range\n      ga.randomInt = function(min, max) {\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n      };\n    };\n\nThe `GA.custom` function is called by Ga as soon as the engine has\nfinished initializing, but before the game runs. This means you\ncan use it to run any other custom setup task that you want to\nperform before any of the game code runs. You could also use the\n`GA.custom` function to overwrite any of Ga's default properties\nwith your own. Go wild!\n\nThe plugins in this file\n------------------------\n\nThe code in this `plugins.js` file is organized into chapters.\nUse your text editor's search features to find what you're looking for.\nHere's the table of contents to get you started:\n\n### Prologue: Polyfills\n\n- Necessary polyfills for some of the API's used in this file. \n\n### Chapter 1: Utilities\n\n`move`: Make a sprite or group move (or an array of them) by updating its velocity.\n`distance`: The distance in pixels between the center point of two sprites.\n`followEase`: Make a sprite ease to the position of another sprite.\n`easeProperty`: Ease a single sprite property to another value.\n`slide`: Ease a sprite to a specific position.\n`fadeIn`: Fade in a sprite.\n`fadeOut`: Fade out a sprite.\n`fade`: Fades in or out.\n`pulse`: Uses the `fade` method to make a sprite's alpha oscillate.\n`follow`: Make a sprite follow another sprite at a fixed speed.\n`rotateSprite`: Make a sprite rotate around the center of another sprite.\n`rotatePoint`: Make any x/y point rotate around any other point.\n`angle`: Get the angle between the center points of two sprites\n`randomInt`: Generate a random integer within a range.\n`randomFloat`: Generate a random floating point number within a range.\n`wait`: Wait for a certain number of milliseconds and then execute a callback function.\n`worldCamera`: A method that creates and returns a camera for a scrolling game world.\n`scaleToWindow`: Automatically scales and centers the game to the maximum browser window area.\n`shake`: Make a sprite or group shake. You can use it for a screen shake effect.\n\n### Chapter 2: The tweening module \n\n`tweens`: An array to store all of Ga's current tweens.\n`updateTweens`: A function that updates all the tweens each frame inside Ga's game loop.\n`ease`: An object that stores references to useful easing functions.\n`tweenProperty`: A generic low-level method that tweens any sprite property.\n`slide`: Make a sprite slide from one x/y position to another.\n`fadeIn`: Fade a sprite in.\n`fadeOut`: Fade a sprite out.\n`pulse`: Make a sprite fade in and out in a loop.\n`makeTween`: A low-level function to help construct complex tweens.\n`scale`: Smoothly change the scale of a sprite.\n`breathe`: A breathing effect that changes the sprite's scale in a continuous loop.\n`strobe`: A psychedelic flashing scale effect.\n`wobble`: Make a sprite wobble like a plate of jelly.\n`removeTween`: A universal method for remove a tween from Ga's engine.\n`followCurve`: Make a sprite follow a bezier curve that you can specify.\n`followPath`: Make a sprite follow a path of connected waypoints.\n`walkCurve`: Make a sprite follow a path of connected curves.\n\n### Chapter 3: Sprite creation tools\n\n`shoot`: A function for making sprites shoot bullets.\n`grid`: Easily plot a grid of sprites. Returns a container full of sprite `children`.\n`progressBar`: A loading progress bar you can use to display while game assets are loading.`\n`particleEffect`: A versatile function for creating particles.\n`emitter`: A particle emitter for creating a constant stream of particles.\n`tilingSprite`: An easy way to create a seamless scrolling background effect.\n\n### Chapter 4: Collision\n\n#### Boundary collisions\n\n`outsideBounds`: Tells you if a sprite has exceeded the boundary of another sprite or container.\n`contain`: Contains a sprite inside another sprite. Optional bounce if the sprite hits the edges.\n\n#### Shape collisions\n\n`hitTestPoint`: Returns `true` or `false` if an x/y point is intersecting a rectangle or circle.\n`hitTestCircle`: Returns `true` if any two circular sprites overlap.\n`hitTestRectangle`: Returns `true` if any two rectangular sprites overlap.\n`hitTestCircleRectangle`: Returns `true` if rectangular and circular sprites overlap.\n`hitTestCirclePoint`: Returns `true` if a point intersects a circle.\n`rectangleCollision`: Prevents two colliding rectangles from overlapping and tells you the collision side\n`circleCollision`: Makes a moving circle bounce away from a stationary circle.\n`movingCircleCollision`: Makes two moving circles bounce apart.\n`multipleCircleCollision`: Bounce apart any two circles that are in the same array.\n`bounceOffSurface`: A helper method that's use internally by these collision functions.\n\n#### 2D tile-based collision utilities\n\n`getIndex`: Converts a sprite's x/y pixel coordinates into an array index number.\n`getTile`: Converts a sprite's index number into x/y pixel coordinates.\n`surroundingCells`: returns an array of 9 index numbers of cells surrounding a center cell.\n`getPoints`: returns an object with the x/y positions of all the sprite's corner points.\n`hitTestTile`: A versatile collision detection function for tile based games.\n`updateMap`: Returns a new map array with the new index positions of sprites.\n\n### Chapter 5: Sprite controllers\n\n`keyControlFourWay`: Assign keyboard keys to make a sprite move at a fixed speed in 4 directions\n\n### Chapter 6: Tiled editor importers\n\n`makeTiledWorld`: Creates a game world using Tiled Editor's JSON export data.\n\n### Chapter 7: The fullscreen module\n\n`requestFullscreen`: Used by `enableFullscreen` to launch fullscreen mode.\n`exitFullscreen`: used by `enableFullscreen` to exit fullsrcreen mode.\n`alignFullscreen`: Used by `enableFullscreen` to scale and center the canvas in fullscreen mode.\n`enableFullscreen`: Enables fullscreen mode when the user clicks or touches the canvas.\n\n### Chapter 8: Sound\n\n`ga.actx`: The audio context.\n`makeSound`: a method for loading and controling sound files.\n`sound`: a method that returns a sound file object.\n`soundEffect`: a versatile method for generating sound effects from pure code.\n`impulseResponse`: A helper method for adding reverb to sounds.\n\n*/\n\n/*\nPrologue\n--------\n\nSome necessary polyfills for some of the newer APIs used in this file\n*/\n\n/*\n### Fixing the WebAudio API.\nThe WebAudio API is so new that it's API is not consistently implemented properly across\nall modern browsers. Thankfully, Chris Wilson's Audio Context Monkey Patch script\nnormalizes the API for maximum compatibility.\n\nhttps://github.com/cwilso/AudioContext-MonkeyPatch/blob/gh-pages/AudioContextMonkeyPatch.js\n\nIt's included here.\nThank you, Chris!\n\n*/\n\n(function (global, exports, perf) {\n  'use strict';\n\n  function fixSetTarget(param) {\n    if (!param)\t// if NYI, just return\n      return;\n    if (!param.setTargetAtTime)\n      param.setTargetAtTime = param.setTargetValueAtTime;\n  }\n\n  if (window.hasOwnProperty('webkitAudioContext') &&\n    !window.hasOwnProperty('AudioContext')) {\n    window.AudioContext = webkitAudioContext;\n\n    if (!AudioContext.prototype.hasOwnProperty('createGain'))\n      AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;\n    if (!AudioContext.prototype.hasOwnProperty('createDelay'))\n      AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;\n    if (!AudioContext.prototype.hasOwnProperty('createScriptProcessor'))\n      AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode;\n\n    AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain;\n    AudioContext.prototype.createGain = function () {\n      var node = this.internal_createGain();\n      fixSetTarget(node.gain);\n      return node;\n    };\n\n    AudioContext.prototype.internal_createDelay = AudioContext.prototype.createDelay;\n    AudioContext.prototype.createDelay = function (maxDelayTime) {\n      var node = maxDelayTime ? this.internal_createDelay(maxDelayTime) : this.internal_createDelay();\n      fixSetTarget(node.delayTime);\n      return node;\n    };\n\n    AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource;\n    AudioContext.prototype.createBufferSource = function () {\n      var node = this.internal_createBufferSource();\n      if (!node.start) {\n        node.start = function (when, offset, duration) {\n          if (offset || duration)\n            this.noteGrainOn(when, offset, duration);\n          else\n            this.noteOn(when);\n        }\n      }\n      if (!node.stop)\n        node.stop = node.noteOff;\n      fixSetTarget(node.playbackRate);\n      return node;\n    };\n\n    AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor;\n    AudioContext.prototype.createDynamicsCompressor = function () {\n      var node = this.internal_createDynamicsCompressor();\n      fixSetTarget(node.threshold);\n      fixSetTarget(node.knee);\n      fixSetTarget(node.ratio);\n      fixSetTarget(node.reduction);\n      fixSetTarget(node.attack);\n      fixSetTarget(node.release);\n      return node;\n    };\n\n    AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter;\n    AudioContext.prototype.createBiquadFilter = function () {\n      var node = this.internal_createBiquadFilter();\n      fixSetTarget(node.frequency);\n      fixSetTarget(node.detune);\n      fixSetTarget(node.Q);\n      fixSetTarget(node.gain);\n      return node;\n    };\n\n    if (AudioContext.prototype.hasOwnProperty('createOscillator')) {\n      AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator;\n      AudioContext.prototype.createOscillator = function () {\n        var node = this.internal_createOscillator();\n        if (!node.start)\n          node.start = node.noteOn;\n        if (!node.stop)\n          node.stop = node.noteOff;\n        fixSetTarget(node.frequency);\n        fixSetTarget(node.detune);\n        return node;\n      };\n    }\n  }\n}(window));\n\n//### Fixing the Fullscreen API.\n//The Fullscreen API is also in flux and has a quirky browser\n//implementations. Here's a fix for it, thanks to Norman Paschke:\n//https://github.com/neovov/Fullscreen-API-Polyfill/blob/master/fullscreen-api-polyfill.js\n\n(function (doc) {\n  // Use JavaScript script mode\n  \"use strict\";\n\n  /*global Element */\n\n  var pollute = true,\n    api,\n    vendor,\n    apis = {\n      // http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html\n      w3: {\n        enabled: \"fullscreenEnabled\",\n        element: \"fullscreenElement\",\n        request: \"requestFullscreen\",\n        exit: \"exitFullscreen\",\n        events: {\n          change: \"fullscreenchange\",\n          error: \"fullscreenerror\"\n        }\n      },\n      webkit: {\n        enabled: \"webkitIsFullScreen\",\n        element: \"webkitCurrentFullScreenElement\",\n        request: \"webkitRequestFullScreen\",\n        exit: \"webkitCancelFullScreen\",\n        events: {\n          change: \"webkitfullscreenchange\",\n          error: \"webkitfullscreenerror\"\n        }\n      },\n      moz: {\n        enabled: \"mozFullScreen\",\n        element: \"mozFullScreenElement\",\n        request: \"mozRequestFullScreen\",\n        exit: \"mozCancelFullScreen\",\n        events: {\n          change: \"mozfullscreenchange\",\n          error: \"mozfullscreenerror\"\n        }\n      },\n      ms: {\n        enabled: \"msFullscreenEnabled\",\n        element: \"msFullscreenElement\",\n        request: \"msRequestFullscreen\",\n        exit: \"msExitFullscreen\",\n        events: {\n          change: \"MSFullscreenChange\",\n          error: \"MSFullscreenError\"\n        }\n      }\n    },\n    w3 = apis.w3;\n\n  // Loop through each vendor's specific API\n  for (vendor in apis) {\n    // Check if document has the \"enabled\" property\n    if (apis[vendor].enabled in doc) {\n      // It seems this browser support the fullscreen API\n      api = apis[vendor];\n      break;\n    }\n  }\n\n  function dispatch(type, target) {\n    var event = doc.createEvent(\"Event\");\n\n    event.initEvent(type, true, false);\n    target.dispatchEvent(event);\n  } // end of dispatch()\n\n  function handleChange(e) {\n    // Recopy the enabled and element values\n    doc[w3.enabled] = doc[api.enabled];\n    doc[w3.element] = doc[api.element];\n\n    dispatch(w3.events.change, e.target);\n  } // end of handleChange()\n\n  function handleError(e) {\n    dispatch(w3.events.error, e.target);\n  } // end of handleError()\n\n  // Pollute only if the API doesn't already exists\n  if (pollute && !(w3.enabled in doc) && api) {\n    // Add listeners for fullscreen events\n    doc.addEventListener(api.events.change, handleChange, false);\n    doc.addEventListener(api.events.error, handleError, false);\n\n    // Copy the default value\n    doc[w3.enabled] = doc[api.enabled];\n    doc[w3.element] = doc[api.element];\n\n    // Match the reference for exitFullscreen\n    doc[w3.exit] = doc[api.exit];\n\n    // Add the request method to the Element's prototype\n    Element.prototype[w3.request] = function () {\n      return this[api.request].apply(this, arguments);\n    };\n  }\n\n  // Return the API found (or undefined if the Fullscreen API is unavailable)\n  return api;\n\n}(document));\n\nGA = GA || {};\nGA.plugins = function (ga) {\n\n  /*\n  Chapter 1: Utilities\n  --------------------\n  */\n\n  //### move\n  //Move a sprite or an array of sprites by adding its\n  //velocity to its position\n  ga.move = function (sprites) {\n    if (sprites instanceof Array === false) {\n      internal_move(sprites)\n    } else {\n      for (var i = 0; i < sprites.length; i++) {\n        internal_move(sprites[i])\n      }\n    }\n  };\n\n  function internal_move(sprite) {\n    sprite.x += sprite.vx | 0;\n    sprite.y += sprite.vy | 0;\n  }\n\n  /*\n  ### distance\n\n  Find the distance in pixels between two sprites.\n  Parameters:\n  a. A sprite object with `centerX` and `centerX` properties.\n  b. A sprite object with `centerY` and `centerY` properties.\n  The function returns the number of pixels distance between the sprites.\n\n  */\n\n  ga.distance = function (s1, s2) {\n    var vx = s2.centerX - s1.centerX,\n      vy = s2.centerY - s1.centerY;\n    return Math.sqrt(vx * vx + vy * vy);\n  };\n\n  /*\n  ### followEase\n\n  Make a sprite ease to the position of another sprite.\n  Parameters:\n  a. A sprite object with `centerX` and `centerY` properties. This is the `follower`\n  sprite.\n  b. A sprite object with `centerX` and `centerY` properties. This is the `leader` sprite that\n  the follower will chase\n  c. The easing value, such as 0.3. A higher number makes the follower move faster\n\n  */\n  ga.followEase = function (follower, leader, speed) {\n\n    //Figure out the distance between the sprites\n    var vx = leader.centerX - follower.centerX,\n      vy = leader.centerY - follower.centerY,\n      distance = Math.sqrt(vx * vx + vy * vy);\n\n    //Move the follower if it's more than 1 pixel\n    //away from the leader\n    if (distance >= 1) {\n      follower.x += vx * speed;\n      follower.y += vy * speed;\n    }\n  };\n\n  /*\n  ### followConstant\n\n  Make a sprite move towards another sprite at a regular speed.\n  Parameters:\n  a. A sprite object with `centerX` and `centerY` properties. This is the `follower`\n  sprite.\n  b. A sprite object with `centerX` and `centerY` properties. This is the `leader` sprite that\n  the follower will chase\n  c. The speed value, such as 3. The is the pixels per frame that the sprite will move. A higher number makes the follower move faster.\n\n  */\n\n  ga.followConstant = function (follower, leader, speed) {\n\n    //Figure out the distance between the sprites\n    var vx = leader.centerX - follower.centerX,\n      vy = leader.centerY - follower.centerY,\n      distance = Math.sqrt(vx * vx + vy * vy);\n\n    //Move the follower if it's more than 1 move\n    //away from the leader\n    if (distance >= speed) {\n      follower.x += (vx / distance) * speed;\n      follower.y += (vy / distance) * speed;\n    }\n  };\n\n  //### rotateAroundSprite\n  //Make a sprite rotate around another sprite\n\n  ga.rotateAroundSprite = function (rotatingSprite, centerSprite, distance, angle) {\n    rotatingSprite.x\n      = centerSprite.centerX - rotatingSprite.parent.x\n      + (distance * Math.cos(angle))\n      - rotatingSprite.halfWidth;\n\n    rotatingSprite.y\n      = centerSprite.centerY - rotatingSprite.parent.y//centerSprite.y\n      + (distance * Math.sin(angle))\n      - rotatingSprite.halfWidth;\n  };\n\n  //### rotateAroundPoint\n  //Make a point rotate around another point.\n  //If distanceX and distanceY are the same value, the rotation will\n  //be circular. If they're different values, the rotation will be\n  //ellipical.\n\n  ga.rotateAroundPoint = function (pointX, pointY, distanceX, distanceY, angle) {\n    var point = {};\n    point.x = pointX + Math.cos(angle) * distanceX;\n    point.y = pointY + Math.sin(angle) * distanceY;\n    return point;\n  };\n\n  /*\n  ### angle\n\n  Return the angle in Radians between two sprites.\n  Parameters:\n  a. A sprite object with `centerX` and `centerY` properties.\n  b. A sprite object with `centerX` and `centerY` properties.\n  You can use it to make a sprite rotate towards another sprite like this:\n\n      box.rotation = angle(box, pointer);\n\n  */\n\n  ga.angle = function (s1, s2) {\n    return Math.atan2(\n      s2.centerY - s1.centerY,\n      s2.centerX - s1.centerX\n    );\n  };\n\n  /*\n  ### random\n\n  Returns a random integer between a minimum and maximum value\n  Parameters:\n  a. An integer.\n  b. An integer.\n  Here's how you can use it to get a random number between, 1 and 10:\n\n      randomInt(1, 10);\n\n  */\n  ga.randomInt = function (min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  };\n\n  //### randomFloat\n  // Returns a random floating point number between a minimum and maximum value\n  ga.randomFloat = function (min, max) {\n    return min + Math.random() * (max - min);\n  }\n\n  //### wait\n  ga.wait = function (duration, callBack) {\n    return setTimeout(callBack, duration);\n  };\n\n  //### worldCamera\n  /*\n  The `worldCamera` method returns a `camera` object\n  with `x` and `y` properties. It has\n  two useful methods: `centerOver`, to center the camera over\n  a sprite, and `follow` to make it follow a sprite.\n  `worldCamera` arguments: worldObject, theCanvas\n  The worldObject needs to have a `width` and `height` property.\n  */\n\n  ga.worldCamera = function (world, canvas) {\n    var camera = {\n      width: canvas.width,\n      height: canvas.height,\n      _x: 0,\n      _y: 0,\n\n      //`x` and `y` getters/setters\n      //When you change the camera's position,\n      //they acutally reposition the world\n      get x() {\n        return this._x;\n      },\n      set x(value) {\n        this._x = value;\n        world.x = -this._x;\n        world._previousX = world.x;\n      },\n      get y() {\n        return this._y;\n      },\n      set y(value) {\n        this._y = value;\n        world.y = -this._y;\n        world._previousY = world.y;\n      },\n      get centerX() {\n        return this.x + (this.width / 2);\n      },\n      get centerY() {\n        return this.y + (this.height / 2);\n      },\n      get rightInnerBoundary() {\n        return this.x + (this.width / 2) + (this.width / 4);\n      },\n      get leftInnerBoundary() {\n        return this.x + (this.width / 2) - (this.width / 4);\n      },\n      get topInnerBoundary() {\n        return this.y + (this.height / 2) - (this.height / 4);\n      },\n      get bottomInnerBoundary() {\n        return this.y + (this.height / 2) + (this.height / 4);\n      },\n      follow: function (sprite) {\n\n        //Check the sprites position in relation to the inner boundary\n        if (sprite.x < this.leftInnerBoundary) {\n          //Move the camera to follow the sprite if the sprite strays outside\n          //this.x = Math.floor(sprite.x - (this.width / 4));\n          this.x = sprite.x - (this.width / 4);\n        }\n        if (sprite.y < this.topInnerBoundary) {\n\n          //this.y = Math.floor(sprite.y - (this.height / 4));\n          this.y = sprite.y - (this.height / 4);\n        }\n        if (sprite.x + sprite.width > this.rightInnerBoundary) {\n\n          //this.x = Math.floor(sprite.x + sprite.width - (this.width / 4 * 3));\n          this.x = sprite.x + sprite.width - (this.width / 4 * 3);\n        }\n        if (sprite.y + sprite.height > this.bottomInnerBoundary) {\n\n          //this.y = Math.floor(sprite.y + sprite.height - (this.height / 4 * 3));\n          this.y = sprite.y + sprite.height - (this.height / 4 * 3);\n        }\n        //If the camera reaches the edge of the map, stop it from moving\n        if (this.x < 0) {\n          this.x = 0;\n        }\n        if (this.y < 0) {\n          this.y = 0;\n        }\n        if (this.x + this.width > world.width) {\n          this.x = world.width - this.width;\n        }\n        if (this.y + this.height > world.height) {\n          this.y = world.height - this.height;\n        }\n      },\n      centerOver: function (sprite) {\n\n        //Center the camera over a sprite\n        this.x = (sprite.x + sprite.halfWidth) - (this.width / 2);\n        this.y = (sprite.y + sprite.halfHeight) - (this.height / 2);\n      }\n    };\n\n    return camera;\n  };\n\n  /*\n ga.worldCamera = function(world, canvas) {\n   var camera = ga.group();\n   camera.width = canvas.width;\n   camera.height = canvas.height;\n   camera._x = 0;\n   camera._y = 0;\n   Object.defineProperties(camera, {\n     x: {\n       get: function() {\n         return this._x; \n       },\n       set: function(value) {\n         this._x = value;\n         world.x = -this._x;\n         //world._previousX = world.x;\n       },\n       enumerable: true, configurable: true\n     },\n     y: {\n       get: function() {\n         return this._y; \n       },\n       set: function(value) {\n         this._y = value;\n         world.y = -this._y;\n         //world._previousY = world.y;\n       },\n       enumerable: true, configurable: true\n     },\n     rightInnerBoundary: {\n       get: function() {\n         return this.x + (this.width / 2) + (this.width / 4);\n       },\n       enumerable: true, configurable: true\n     },\n     leftInnerBoundary: {\n       get: function() {\n         return this.x + (this.width / 2) - (this.width / 4);\n       },\n       enumerable: true, configurable: true\n     },\n     topInnerBoundary: {\n       get: function() {\n         return this.y + (this.height / 2) - (this.height / 4);\n       },\n       enumerable: true, configurable: true\n     },\n     bottomInnerBoundary: {\n       get: function() {\n         return this.y + (this.height / 2) + (this.height / 4);\n       },\n       enumerable: true, configurable: true\n     }\n   });\n   camera.follow = function(sprite) {\n     //Check the sprites position in relation to the inner boundary\n     if(sprite.x < this.leftInnerBoundary) {\n       //Move the camera to follow the sprite if the sprite strays outside\n       this.x = Math.floor(sprite.x - (this.width / 4));\n     }\n     if(sprite.y < this.topInnerBoundary) {\n       this.y = Math.floor(sprite.y - (this.height / 4));\n     }\n     if(sprite.x + sprite.width > this.rightInnerBoundary) {\n       this.x = Math.floor(sprite.x + sprite.width - (this.width / 4 * 3));\n     }\n     if(sprite.y + sprite.height > this.bottomInnerBoundary) {\n       this.y = Math.floor(sprite.y + sprite.height - (this.height / 4 * 3));\n     }\n     //If the camera reaches the edge of the map, stop it from moving\n     if(this.x < 0) {\n       this.x = 0;\n     }\n     if(this.y < 0) {\n       this.y = 0;\n     }\n     if(this.x + this.width > world.width) {\n       this.x = world.width - this.width;\n     }\n     if(this.y + this.height > world.height) {\n       this.y = world.height - this.height;\n     }\n   };\n   camera.centerOver = function(sprite) {\n     //Center the camera over a sprite\n     this.x = (sprite.x + sprite.halfWidth) - (this.width / 2);\n     this.y = (sprite.y + sprite.halfHeight) - (this.height / 2);\n     console.log(world)\n   };\n\n   return camera;\n };\n */\n  //### scaleToWindow\n  //Center and scale the game engine inside the HTML page \n  ga.scaleToWindow = function (backgroundColor) {\n\n    backgroundColor = backgroundColor || \"#2C3539\";\n    var scaleX, scaleY, scale, center;\n\n    //1. Scale the canvas to the correct size\n    //Figure out the scale amount on each axis\n    scaleX = window.innerWidth / ga.canvas.width;\n    scaleY = window.innerHeight / ga.canvas.height;\n\n    //Scale the canvas based on whichever value is less: `scaleX` or `scaleY`\n    scale = Math.min(scaleX, scaleY);\n    ga.canvas.style.transformOrigin = \"0 0\";\n    ga.canvas.style.transform = \"scale(\" + scale + \")\";\n\n    //2. Center the canvas.\n    //Decide whether to center the canvas vertically or horizontally.\n    //Wide canvases should be centered vertically, and \n    //square or tall canvases should be centered horizontally\n    if (ga.canvas.width > ga.canvas.height) {\n      if (ga.canvas.width * scale < window.innerWidth) {\n        center = \"horizontally\";\n      } else {\n        center = \"vertically\";\n      }\n    } else {\n      if (ga.canvas.height * scale < window.innerHeight) {\n        center = \"vertically\";\n      } else {\n        center = \"horizontally\";\n      }\n    }\n\n    //Center horizontally (for square or tall canvases)\n    var margin;\n    if (center === \"horizontally\") {\n      margin = (window.innerWidth - ga.canvas.width * scale) / 2;\n      ga.canvas.style.marginLeft = margin + \"px\";\n      ga.canvas.style.marginRight = margin + \"px\";\n    }\n\n    //Center vertically (for wide canvases) \n    if (center === \"vertically\") {\n      margin = (window.innerHeight - ga.canvas.height * scale) / 2;\n      ga.canvas.style.marginTop = margin + \"px\";\n      ga.canvas.style.marginBottom = margin + \"px\";\n    }\n\n    //3. Remove any padding from the canvas  and body and set the canvas\n    //display style to \"block\"\n    ga.canvas.style.paddingLeft = 0;\n    ga.canvas.style.paddingRight = 0;\n    ga.canvas.style.paddingTop = 0;\n    ga.canvas.style.paddingBottom = 0;\n    ga.canvas.style.display = \"block\";\n\n    //4. Set the color of the HTML body background\n    document.body.style.backgroundColor = backgroundColor;\n\n    //5. Set the game engine and pointer to the correct scale. \n    //This is important for correct hit testing between the pointer and sprites\n    ga.pointer.scale = scale;\n    ga.scale = scale;\n\n    //It's important to set `canvasHasBeenScaled` to `true` so that\n    //the scale values aren't overridden by Ga's check for fullscreen\n    //mode in the `update` function (in the `ga.js` file.)\n    ga.canvas.scaled = true;\n\n    //Fix some quirkiness in scaling for Safari\n    var ua = navigator.userAgent.toLowerCase();\n    if (ua.indexOf(\"safari\") != -1) {\n      if (ua.indexOf(\"chrome\") > -1) {\n        // Chrome\n      } else {\n        // Safari\n        ga.canvas.style.maxHeight = \"100%\";\n        ga.canvas.style.minHeight = \"100%\";\n      }\n    }\n  };\n\n  /*\n  ###shakingSprites\n\n  An array to store all the shaking sprites in the game\n  */\n\n  ga.shakingSprites = [];\n\n  /*\n  ###updateShakingSprites\n  \n  `updateShakingSprites` loops through all the sprites in `ga.particles`\n  and runs their `updateParticles` functions.\n  */\n\n  ga.updateShakingSprites = function () {\n\n    //Update all the shaking sprites\n    if (ga.shakingSprites.length > 0) {\n      for (var i = ga.shakingSprites.length - 1; i >= 0; i--) {\n        var shakingSprite = ga.shakingSprites[i];\n        if (shakingSprite.updateShake) shakingSprite.updateShake();\n      }\n    }\n  }\n\n  //Push `updateShakingSprites` into the `ga.updateFunctions` array so that\n  //it runs inside Ga's game loop. (See the `ga.update` method in the \n  //`ga.js` file to see how this works.\n  ga.updateFunctions.push(ga.updateShakingSprites);\n\n  /*\n  shake\n  -----\n\n  Used to create a shaking effect, like a screen shake.\n  `shake` arguments: sprite, magnitude, angularShake?\n  Use it like this:\n\n      g.shake(sprite, 0.05, true);\n\n  If `angularShake?` (the 3rd argument) is `true`, the sprite will shake around\n  its axis. The `magnitude` will be the maximum value, in\n  radians, that it should shake. \n  \n  If `angularShake?` is `false` the shake effect will happen on the x/y axis. \n  \n      g.shake(sprite, 16, false);\n\n  In that case the magnitude will be the maximum amount of \n  displacement, in pixels.\n  */\n\n  ga.shake = function (sprite, magnitude, angular) {\n\n    if (magnitude === undefined) magnitude = 16;\n    if (angular === undefined) angular = false;\n\n    //A counter to count the number of shakes\n    var counter = 1;\n\n    //The total number of shakes (there will be 1 shake per frame)\n    var numberOfShakes = 10;\n\n    //Capture the sprite's position and angle so you can\n    //restore them after the shaking has finished\n    var startX = sprite.x,\n      startY = sprite.y,\n      startAngle = sprite.rotation;\n\n    //Divide the magnitude into 10 units so that you can \n    //reduce the amount of shake by 10 percent each frame\n    var magnitudeUnit = magnitude / numberOfShakes;\n\n    //The `randomInt` helper function\n    var randomInt = function (min, max) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    };\n\n    //Add the sprite to the `shakingSprites` array if it\n    //isn't already there\n    if (ga.shakingSprites.indexOf(sprite) === -1) {\n\n      ga.shakingSprites.push(sprite);\n\n      //Add an `updateShake` method to the sprite.\n      //The `updateShake` method will be called each frame\n      //in the game loop. The shake effect type can be either\n      //up and down (x/y shaking) or angular (rotational shaking).\n      sprite.updateShake = function () {\n        if (angular) {\n          angularShake();\n        } else {\n          upAndDownShake();\n        }\n      };\n    }\n\n    //The `upAndDownShake` function\n    function upAndDownShake() {\n\n      //Shake the sprite while the `counter` is less than \n      //the `numberOfShakes`\n      if (counter < numberOfShakes) {\n\n        //Reset the sprite's position at the start of each shake\n        sprite.x = startX;\n        sprite.y = startY;\n\n        //Reduce the magnitude\n        magnitude -= magnitudeUnit;\n\n        //Randomly change the sprite's position\n        sprite.x += randomInt(-magnitude, magnitude);\n        sprite.y += randomInt(-magnitude, magnitude);\n\n        //Add 1 to the counter\n        counter += 1;\n      }\n\n      //When the shaking is finished, restore the sprite to its original \n      //position and remove it from the `shakingSprites` array\n      if (counter >= numberOfShakes) {\n        sprite.x = startX;\n        sprite.y = startY;\n        ga.shakingSprites.splice(ga.shakingSprites.indexOf(sprite), 1);\n      }\n    }\n\n    //The `angularShake` function\n    //First set the initial tilt angle to the right (+1) \n    var tiltAngle = 1;\n\n    function angularShake() {\n      if (counter < numberOfShakes) {\n\n        //Reset the sprite's rotation\n        sprite.rotation = startAngle;\n\n        //Reduce the magnitude\n        magnitude -= magnitudeUnit;\n\n        //Rotate the sprite left or right, depending on the direction,\n        //by an amount in radians that matches the magnitude\n        sprite.rotation = magnitude * tiltAngle;\n        counter += 1;\n\n        //Reverse the tilt angle so that the sprite is tilted\n        //in the opposite direction for the next shake\n        tiltAngle *= -1;\n      }\n\n      //When the shaking is finished, reset the sprite's angle and\n      //remove it from the `shakingSprites` array\n      if (counter >= numberOfShakes) {\n        sprite.rotation = startAngle;\n        ga.shakingSprites.splice(ga.shakingSprites.indexOf(sprite), 1);\n      }\n    }\n  };\n\n  /*\n  Chapter 2: The tweening module\n  ---------------------------------------------------------\n\n  Ga has some special tween functions to help you manage scene transitions\n  or to make sprites move in a fixed or repeating way:\n\n      `slide`: Make a sprite slide from one x/y position to another.\n      `fadeIn`: Fade a sprite in.\n      `fadeOut`: Fade a sprite out.\n      `pulse`: Make a sprite fade in and out in a loop.\n      `scale`: Smoothly change the scale of a sprite.\n      `breathe`: A breathing effect that changes the sprite's scale in a loop.\n      `strobe`: A psychedelic flashing scale effect.\n      `wobble`: Make a sprite wobble like a plate of jelly.\n\n  All these methods return a `tween` object. You\n  attach an `onComplete` method to the `tween` object to do something\n  when the tween has finished. It also has a Boolean `playing`\n  property that tells you whether or not the tween is playing. Use\n  `tween.pause()` and `tween.play()` to pause and play the tweens at\n  any time. You can completely remove a tween with\n  `ga.removeTween(tweenObject)`.\n\n  Most of these methods have a `yoyo` Boolean argument that, if `true`,\n  will make the sprite bounce back and\n  forth between its start and end points, forever. You can supply an\n  optional `delay` argument that defines how long, in milliseconds, the\n  tween should hold its position until it bounces back again. \n\n  All of these special tweens are managed in Ga's `tweens` array. Ga's game loop\n  calls each tween object's `update` function each frame.\n\n  See the `scenesAndTweening` and `tweening.html` file in the `examples` folder for a demonstration of how\n  to use these tweening methods.\n\n  */\n\n  /*\n  ###tweens\n  An array to store all the tweens in the game\n  */\n\n  ga.tweens = [];\n\n  /*\n  ###updateTweens\n  `updateTweens` loops through all the sprites in `ga.particles`\n  and runs their `updateParticles` functions.\n  */\n\n  ga.updateTweens = function () {\n\n    //Update all the particles in the game.\n    if (ga.tweens.length > 0) {\n      for (var i = ga.tweens.length - 1; i >= 0; i--) {\n        var tween = ga.tweens[i];\n        if (tween) tween.update();\n      }\n    }\n  }\n\n  //Push `updateTweens` into the `ga.updateFunctions` array so that\n  //it runs inside Ga's game loop. (See the `ga.update` method in the \n  //`ga.js` file to see how this works.\n  ga.updateFunctions.push(ga.updateTweens);\n\n  //###Easing functions\n  //These are low-level functions that you won't use directly.\n  //Instead, their used by the higher-level tweening functions.\n\n  //Bezier curve\n  ga.cubicBezier = function (t, a, b, c, d) {\n    var t2 = t * t;\n    var t3 = t2 * t;\n    return a\n      + (-a * 3 + t * (3 * a - a * t)) * t\n      + (3 * b + t * (-6 * b + b * 3 * t)) * t\n      + (c * 3 - c * 3 * t) * t2 + d * t3;\n  }\n\n  //The `ease` object. It stores all the easing functions\n  var ease = {\n\n    //Linear\n    linear: function (x) { return x; },\n\n    //Smoothstep\n    smoothstep: function (x) { return x * x * (3 - 2 * x); },\n    smoothstepSquared: function (x) { return Math.pow((x * x * (3 - 2 * x)), 2); },\n    smoothstepCubed: function (x) { return Math.pow((x * x * (3 - 2 * x)), 3); },\n\n    //Acceleration\n    acceleration: function (x) { return x * x; },\n    accelerationCubed: function (x) { return Math.pow(x * x, 3); },\n\n    //Deceleration\n    deceleration: function (x) { return 1 - Math.pow(1 - x, 2); },\n    decelerationCubed: function (x) { return 1 - Math.pow(1 - x, 3); },\n\n    //Sine\n    sine: function (x) { return Math.sin(x * Math.PI / 2); },\n    sineSquared: function (x) { return Math.pow(Math.sin(x * Math.PI / 2), 2); },\n    sineCubed: function (x) { return Math.pow(Math.sin(x * Math.PI / 2), 2); },\n    inverseSine: function (x) { return 1 - Math.sin((1 - x) * Math.PI / 2); },\n    inverseSineSquared: function (x) { return 1 - Math.pow(Math.sin((1 - x) * Math.PI / 2), 2); },\n    inverseSineCubed: function (x) { return 1 - Math.pow(Math.sin((1 - x) * Math.PI / 2), 3); },\n\n    //Spline\n    spline: function (t, p0, p1, p2, p3) {\n      return 0.5 * (\n        (2 * p1) +\n        (-p0 + p2) * t +\n        (2 * p0 - 5 * p1 + 4 * p2 - p3) * t * t +\n        (-p0 + 3 * p1 - 3 * p2 + p3) * t * t * t\n      );\n    }\n  };\n\n  //###`tweenProperty`\n  //A low-level function that you can use to tween any sprite\n  //property. It's used by all the higher-level tween functions,\n  //but you can use it to create your own custom tween effects.\n\n  ga.tweenProperty = function (\n    sprite,                  //Sprite object\n    property,                //String property\n    startValue,              //Tween start value\n    endValue,                //Tween end value\n    totalFrames,             //Duration in frames\n    type,                    //The easing type\n    yoyo,                    //Yoyo?\n    delayBeforeRepeat        //Delay in milliseconds before repeating\n  ) {\n\n    //Set defaults\n    if (totalFrames === undefined) totalFrames = 60;\n    if (type === undefined) type = \"smoothstep\";\n    if (yoyo === undefined) yoyo = false;\n    if (delayBeforeRepeat === undefined) delayBeforeRepeat = 0;\n\n    //Create the tween object\n    var o = {};\n\n    //If the tween is a bounce type (a spline), set the\n    //start and end magnitude values\n    var typeArray = type.split(\" \");\n    if (typeArray[0] === \"bounce\") {\n      o.startMagnitude = parseInt(typeArray[1]);\n      o.endMagnitude = parseInt(typeArray[2]);\n    }\n\n    //Use `o.start` to make a new tween using the current\n    //end point values\n    o.start = function (startValue, endValue) {\n\n      //Clone the start and end values so that any possible references to sprite\n      //properties are converted to ordinary numbers \n      o.startValue = JSON.parse(JSON.stringify(startValue));\n      o.endValue = JSON.parse(JSON.stringify(endValue));\n      o.playing = true;\n      o.totalFrames = totalFrames;\n      o.frameCounter = 0;\n\n      //Add the tween to the global `tweens` array. The `tweens` array is\n      //updated on each frame\n      ga.tweens.push(o);\n    };\n\n    //Call `o.start` to start the tween\n    o.start(startValue, endValue);\n\n    //The `update` method will be called on each frame by the game loop.\n    //This is what makes the tween move\n    o.update = function () {\n\n      var time, curvedTime;\n\n      if (o.playing) {\n\n        //If the elapsed frames are less than the total frames,\n        //use the tweening formulas to move the sprite\n        if (o.frameCounter < o.totalFrames) {\n\n          //Find the normalized value\n          var normalizedTime = o.frameCounter / o.totalFrames;\n\n          //Select the correct easing function from the \n          //`ease` object’s library of easing functions\n\n          //If it's not a spline, use one of the ordinary easing functions\n          if (typeArray[0] !== \"bounce\") {\n            curvedTime = ease[type](normalizedTime);\n          }\n\n          //If it's a spline, use the `spline` function and apply the\n          //2 additional `type` array values as the spline's start and\n          //end points\n          else {\n            curvedTime = ease.spline(normalizedTime, o.startMagnitude, 0, 1, o.endMagnitude);\n          }\n\n          //Interpolate the sprite's property based on the curve\n          sprite[property] = (o.endValue * curvedTime) + (o.startValue * (1 - curvedTime));\n\n          o.frameCounter += 1;\n        }\n\n        //When the tween has finished playing, run the end tasks\n        else {\n          o.end();\n        }\n      }\n    };\n\n    //The `end` method will be called when the tween is finished\n    o.end = function () {\n\n      //Set `playing` to `false`\n      o.playing = false;\n\n      //Call the tween's `onComplete` method, if it's been assigned\n      if (o.onComplete) o.onComplete();\n\n      //Remove the tween from the `tweens` array\n      ga.tweens.splice(ga.tweens.indexOf(o), 1);\n\n      //If the tween's `yoyo` property is `true`, create a new tween\n      //using the same values, but use the current tween's `startValue`\n      //as the next tween's `endValue` \n      if (yoyo) {\n        ga.wait(delayBeforeRepeat, function () {\n          o.start(o.endValue, o.startValue);\n        });\n      }\n    };\n\n    //Pause and play methods\n    o.play = function () { o.playing = true; };\n    o.pause = function () { o.playing = false; };\n\n    //Return the tween object\n    return o;\n  }\n\n  /* High level tween functions */\n\n  //###`fadeOut`\n  //Fade a sprite out, over a duration in frames.\n  ga.fadeOut = function (sprite, frames) {\n    if (frames === undefined) frames = 60;\n    return ga.tweenProperty(\n      sprite, \"alpha\", sprite.alpha, 0, frames, \"sine\"\n    );\n  }\n\n  //###`fadeIn`\n  //Fade a sprite in, over a duration in frames.\n  ga.fadeIn = function (sprite, frames) {\n    if (frames === undefined) frames = 60;\n    return ga.tweenProperty(\n      sprite, \"alpha\", sprite.alpha, 1, frames, \"sine\"\n    );\n  }\n\n  //`pulse`\n  //Fades the sprite in and out at a steady rate over a duration in\n  //frames. Set the `minAlpha` to something greater than 0 if you\n  //don't want the sprite to fade away completely.\n  ga.pulse = function (sprite, frames, minAlpha) {\n    if (frames === undefined) frames = 60;\n    if (minAlpha === undefined) minAlpha = 0;\n    return ga.tweenProperty(\n      sprite, \"alpha\", sprite.alpha, minAlpha, frames, \"smoothstep\", true\n    );\n  }\n\n  //`makeTween` is a general function for making complex tweens\n  //out of multiple `tweenProperty` functions. It's one argument,\n  //`tweensToAdd` is an array containing multiple `tweenProperty` calls.\n  //(See the `tweenProperty` function above for information on how it\n  //works.)\n\n  ga.makeTween = function (tweensToAdd) {\n\n    //Create an object to manage the tweens\n    var o = {};\n\n    //Create a `tweens` array to store the new tweens\n    o.tweens = [];\n\n    //Make a new tween for each array\n    tweensToAdd.forEach(function (tweenPropertyArguments) {\n\n      //Use the tween property arguments to make a new tween\n      var newTween = ga.tweenProperty(\n        tweenPropertyArguments[0],\n        tweenPropertyArguments[1],\n        tweenPropertyArguments[2],\n        tweenPropertyArguments[3],\n        tweenPropertyArguments[4],\n        tweenPropertyArguments[5],\n        tweenPropertyArguments[6],\n        tweenPropertyArguments[7]\n      );\n\n      //Push the new tween into this object's internal `tweens` array\n      o.tweens.push(newTween);\n    });\n\n    //Add a counter to keep track of the\n    //number of tweens that have completed their actions\n    var completionCounter = 0;\n\n    //`o.completed` will be called each time one of the tweens\n    //finishes\n    o.completed = function () {\n\n      //Add 1 to the `completionCounter`\n      completionCounter += 1;\n\n      //If all tweens have finished, call the user-defined `onComplete`\n      //method, if it's been assigned. Reset the `completionCounter`\n      if (completionCounter === o.tweens.length) {\n        if (o.onComplete) o.onComplete();\n        completionCounter = 0;\n      }\n    };\n\n    //Add `onComplete` methods to all tweens\n    o.tweens.forEach(function (tween) {\n      tween.onComplete = function () { o.completed(); };\n    });\n\n    //Add pause and play methods to control all the tweens\n    o.pause = function () {\n      o.tweens.forEach(function (tween) {\n        tween.playing = false;\n      });\n    };\n    o.play = function () {\n      o.tweens.forEach(function (tween) {\n        tween.playing = true;\n      });\n    };\n\n    //Return the tween object\n    return o;\n  }\n\n  //###`slide`\n  //Make a sprite slide from one x/y position to another.\n  //Use `slide` like this:\n  //var spriteSlide = g.slide(sprite, 400, 0, 60, \"smoothstep\", true, 0);\n\n  ga.slide = function (\n    sprite, endX, endY,\n    frames, type, yoyo, delayBeforeRepeat\n  ) {\n\n    //Set defaults\n    if (frames === undefined) frames = 60;\n    if (type === undefined) type = \"smoothstep\";\n    if (yoyo === undefined) yoyo = false;\n    if (delayBeforeRepeat === undefined) delayBeforeRepeat = 0;\n\n    return ga.makeTween([\n\n      //Create the x axis tween\n      [sprite, \"x\", sprite.x, endX, frames, type, yoyo, delayBeforeRepeat],\n\n      //Create the y axis tween\n      [sprite, \"y\", sprite.y, endY, frames, type, yoyo, delayBeforeRepeat]\n\n    ]);\n  }\n\n  //###`breathe`\n  //Make a sprite appear to breathe, by changing its scale in a\n  //continuous loop.\n  //Use it like this:\n  //var spriteBreathe = g.breathe(sprite, 1.2, 1.2, 60, true, 300);\n\n  ga.breathe = function (\n    sprite, endScaleX, endScaleY,\n    frames, yoyo, delayBeforeRepeat\n  ) {\n\n    //Set defaults\n    if (frames === undefined) frames = 60;\n    if (yoyo === undefined) yoyo = true;\n    if (delayBeforeRepeat === undefined) delayBeforeRepeat = 0;\n\n    return ga.makeTween([\n\n      //Create the scaleX tween\n      [\n        sprite, \"scaleX\", sprite.scaleX, endScaleX,\n        frames, \"smoothstepSquared\", yoyo, delayBeforeRepeat\n      ],\n\n      //Create the scaleY tween\n      [\n        sprite, \"scaleY\", sprite.scaleY, endScaleY,\n        frames, \"smoothstepSquared\", yoyo, delayBeforeRepeat\n      ]\n    ]);\n  }\n\n  //###`scale` smoothly change a sprite's scale. Use it like this:\n  //var spriteScale = g.scale(sprite, finalScaleX, finalScaleY, frames);\n\n  ga.scale = function (sprite, endScaleX, endScaleY, frames) {\n\n    //Set defaults\n    if (frames === undefined) frames = 60;\n\n    return ga.makeTween([\n\n      //Create the scaleX tween\n      [\n        sprite, \"scaleX\", sprite.scaleX, endScaleX,\n        frames, \"smoothstep\", false\n      ],\n\n      //Create the scaleY tween\n      [\n        sprite, \"scaleY\", sprite.scaleY, endScaleY,\n        frames, \"smoothstep\", false\n      ]\n    ]);\n  }\n\n  //`strobe`\n  //A rapid looping scale effect. Use it like this:\n  //var spriteStrobe = g.strobe(sprite, 1.3, 10, 20, 10);\n\n  ga.strobe = function (\n    sprite, scaleFactor, startMagnitude, endMagnitude,\n    frames, yoyo, delayBeforeRepeat\n  ) {\n\n    //Set defaults\n    if (scaleFactor === undefined) scaleFactor = 1.3;\n    if (startMagnitude === undefined) startMagnitude = 10;\n    if (endMagnitude === undefined) endMagnitude = 20;\n    if (frames === undefined) frames = 10;\n    if (yoyo === undefined) yoyo = true;\n    if (delayBeforeRepeat === undefined) delayBeforeRepeat = 0;\n\n    var bounce = \"bounce \" + startMagnitude + \" \" + endMagnitude;\n\n    return ga.makeTween([\n\n      //Create the scaleX tween\n      [\n        sprite, \"scaleX\", sprite.scaleX, scaleFactor, frames,\n        bounce, yoyo, delayBeforeRepeat\n      ],\n\n      //Create the scaleY tween\n      [\n        sprite, \"scaleY\", sprite.scaleY, scaleFactor, frames,\n        bounce, yoyo, delayBeforeRepeat\n      ]\n    ]);\n  }\n\n  //###`wobble`\n  //Make a sprite wobble like a plate of jelly. Use it like this:\n  //var spriteWobble = g.wobble(sprite, 1.2, 1.2);\n\n  ga.wobble = function (\n    sprite,\n    scaleFactorX,\n    scaleFactorY,\n    frames,\n    xStartMagnitude,\n    xEndMagnitude,\n    yStartMagnitude,\n    yEndMagnitude,\n    friction,\n    yoyo,\n    delayBeforeRepeat\n  ) {\n\n    //Set defaults\n    if (scaleFactorX === undefined) scaleFactorX = 1.2;\n    if (scaleFactorY === undefined) scaleFactorY = 1.2;\n    if (frames === undefined) frames = 10;\n    if (xStartMagnitude === undefined) xStartMagnitude = 10;\n    if (xEndMagnitude === undefined) xEndMagnitude = 10;\n    if (yStartMagnitude === undefined) yStartMagnitude = -10;\n    if (yEndMagnitude === undefined) yEndMagnitude = -10;\n    if (friction === undefined) friction = 0.98;\n    if (yoyo === undefined) yoyo = true;\n    if (delayBeforeRepeat === undefined) delayBeforeRepeat = 0;\n\n    var bounceX = \"bounce \" + xStartMagnitude + \" \" + xEndMagnitude,\n      bounceY = \"bounce \" + yStartMagnitude + \" \" + yEndMagnitude;\n\n    var o = ga.makeTween([\n\n      //Create the scaleX tween\n      [\n        sprite, \"scaleX\", sprite.scaleX, scaleFactorX, frames,\n        bounceX, yoyo, delayBeforeRepeat\n      ],\n\n      //Create the scaleY tween\n      [\n        sprite, \"scaleY\", sprite.scaleY, scaleFactorY, frames,\n        bounceY, yoyo, delayBeforeRepeat\n      ]\n    ]);\n\n    //Add some friction to the `endValue` at the end of each tween \n    o.tweens.forEach(function (tween) {\n      tween.onComplete = function () {\n\n        //Add friction if the `endValue` is greater than 1.\n        if (tween.endValue > 1) {\n          tween.endValue *= friction;\n\n          //Set the `endValue` to 1 when the effect is finished and \n          //remove the tween from the global `tweens` array.\n          if (tween.endValue <= 1) {\n            tween.endValue = 1;\n            ga.removeTween(tween);\n          }\n        }\n      };\n    });\n\n    return o;\n  }\n  /*\n  ###removeTween\n  A utility to remove tweens from the game\n\n  */\n  ga.removeTween = function (tweenObject) {\n\n    //Remove the tween if `tweenObject` doesn't have any nested\n    //tween objects\n    if (!tweenObject.tweens) {\n      tweenObject.pause();\n      ga.tweens.splice(ga.tweens.indexOf(tweenObject), 1);\n\n      //Otherwise, remove the nested tween objects\n    } else {\n      tweenObject.pause();\n      tweenObject.tweens.forEach(function (element) {\n        ga.tweens.splice(ga.tweens.indexOf(element), 1);\n      });\n    }\n  }\n\n  /*\n  followCurve\n  ------------\n  */\n\n  ga.followCurve = function (\n    sprite,\n    pointsArray,\n    totalFrames,\n    type,\n    yoyo,\n    delayBeforeRepeat\n  ) {\n\n    //Set defaults\n    if (type === undefined) type = \"smoothstep\";\n    if (yoyo === undefined) yoyo = false;\n    if (delayBeforeRepeat === undefined) delayBeforeRepeat = 0;\n\n    //Create the tween object\n    var o = {};\n\n    //If the tween is a bounce type (a spline), set the\n    //start and end magnitude values\n    var typeArray = type.split(\" \");\n    if (typeArray[0] === \"bounce\") {\n      o.startMagnitude = parseInt(typeArray[1]);\n      o.endMagnitude = parseInt(typeArray[2]);\n    }\n\n    //Use `tween.start` to make a new tween using the current\n    //end point values\n    o.start = function (pointsArray) {\n      o.playing = true;\n      o.totalFrames = totalFrames;\n      o.frameCounter = 0;\n\n      //Clone the points array\n      o.pointsArray = JSON.parse(JSON.stringify(pointsArray));\n\n      //Add the tween to the global `tweens` array. The global `tweens` array is\n      //updated on each frame\n      ga.tweens.push(o);\n    };\n\n    //Call `tween.start` to start the first tween\n    o.start(pointsArray);\n\n    //The `update` method will be called on each frame by the game loop.\n    //This is what makes the tween move\n    o.update = function () {\n\n      var normalizedTime, curvedTime,\n        p = o.pointsArray;\n\n      if (o.playing) {\n\n        //If the elapsed frames are less than the total frames,\n        //use the tweening formulas to move the sprite\n        if (o.frameCounter < o.totalFrames) {\n\n          //Find the normalized value\n          normalizedTime = o.frameCounter / o.totalFrames;\n\n          //Select the correct easing function\n\n          //If it's not a spline, use one of the ordinary tween\n          //functions\n          if (typeArray[0] !== \"bounce\") {\n            curvedTime = ease[type](normalizedTime);\n          }\n\n          //If it's a bounce type, use the `spine` function and apply the\n          //2 additional `type` array values as the spline's start and\n          //end points\n          else {\n            curvedTime = ease.spline(normalizedTime, o.startMagnitude, 0, 1, o.endMagnitude);\n          }\n\n          //Apply the Bezier curve to the sprite's position \n          sprite.x = ga.cubicBezier(curvedTime, p[0][0], p[1][0], p[2][0], p[3][0]);\n          sprite.y = ga.cubicBezier(curvedTime, p[0][1], p[1][1], p[2][1], p[3][1]);\n\n          //Add one to the `elapsedFrames`\n          o.frameCounter += 1;\n        }\n\n        //When the tween has finished playing, run the end tasks\n        else {\n          o.end();\n        }\n      }\n    };\n\n    //The `end` method will be called when the tween is finished\n    o.end = function () {\n\n      //Set `playing` to `false`\n      o.playing = false;\n\n      //Call the tween's `onComplete` method, if it's been\n      //assigned\n      if (o.onComplete) o.onComplete();\n\n      //Remove the tween from the global `tweens` array\n      ga.tweens.splice(ga.tweens.indexOf(o), 1);\n\n      //If the tween's `yoyo` property is `true`, reverse the array and\n      //use it to create a new tween\n      if (yoyo) {\n        ga.wait(delayBeforeRepeat, function () {\n          o.pointsArray = o.pointsArray.reverse();\n          o.start(o.pointsArray);\n        });\n      }\n    };\n\n    //Pause and play methods\n    o.pause = function () {\n      o.playing = false;\n    };\n    o.play = function () {\n      o.playing = true;\n    };\n\n    //Return the tween object\n    return o;\n  };\n\n\n  ga.walkPath = function (\n    sprite,                   //The sprite\n    originalPathArray,        //A 2D array of waypoints\n    totalFrames,              //The duration, in frames\n    type,                     //The easing type\n    loop,                     //Should the animation loop?\n    yoyo,                     //Should the direction reverse?\n    delayBetweenSections      //Delay, in milliseconds, between sections\n  ) {\n\n    //Set defaults\n    if (totalFrames === undefined) totalFrames = 300;\n    if (type === undefined) type = \"smoothstep\";\n    if (loop === undefined) loop = false;\n    if (yoyo === undefined) yoyo = false;\n    if (delayBetweenSections === undefined) delayBetweenSections = 0;\n\n    //Clone the path array so that any possible references to sprite\n    //properties are converted into ordinary numbers \n    var pathArray = JSON.parse(JSON.stringify(originalPathArray));\n\n    //Figure out the duration, in frames, of each path section by \n    //dividing the `totalFrames` by the length of the `pathArray`\n    var frames = totalFrames / pathArray.length;\n\n    //Set the current point to 0, which will be the first waypoint\n    var currentPoint = 0;\n\n    //Make the first path using the internal `makePath` function (below)\n    var tween = makePath(currentPoint);\n\n    //The `makePath` function creates a single tween between two points and\n    //then schedules the next path to be made after it\n\n    function makePath(currentPoint) {\n\n      //Use the `makeTween` function to tween the sprite's\n      //x and y position\n      var tween = ga.makeTween([\n\n        //Create the x axis tween between the first x value in the\n        //current point and the x value in the following point\n        [\n          sprite,\n          \"x\",\n          pathArray[currentPoint][0],\n          pathArray[currentPoint + 1][0],\n          frames,\n          type\n        ],\n\n        //Create the y axis tween in the same way\n        [\n          sprite,\n          \"y\",\n          pathArray[currentPoint][1],\n          pathArray[currentPoint + 1][1],\n          frames,\n          type\n        ]\n      ]);\n\n      //When the tween is complete, advance the `currentPoint` by one.\n      //Add an optional delay between path segments, and then make the\n      //next connecting path\n      tween.onComplete = function () {\n\n        //Advance to the next point\n        currentPoint += 1;\n\n        //If the sprite hasn't reached the end of the\n        //path, tween the sprite to the next point\n        if (currentPoint < pathArray.length - 1) {\n          ga.wait(delayBetweenSections, function () {\n            tween = makePath(currentPoint);\n          });\n        }\n\n        //If we've reached the end of the path, optionally\n        //loop and yoyo it\n        else {\n\n          //Reverse the path if `loop` is `true`\n          if (loop) {\n\n            //Reverse the array if `yoyo` is `true`\n            if (yoyo) pathArray.reverse();\n\n            //Optionally wait before restarting\n            ga.wait(delayBetweenSections, function () {\n\n              //Reset the `currentPoint` to 0 so that we can\n              //restart at the first point\n              currentPoint = 0;\n\n              //Set the sprite to the first point\n              sprite.x = pathArray[0][0];\n              sprite.y = pathArray[0][1];\n\n              //Make the first new path\n              tween = makePath(currentPoint);\n\n              //... and so it continues!\n            });\n          }\n        }\n      };\n\n      //Return the path tween to the main function\n      return tween;\n    }\n\n    //Pass the tween back to the main program\n    return tween;\n  };\n\n  ga.walkCurve = function (\n    sprite,                  //The sprite\n    pathArray,               //2D array of Bezier curves\n    totalFrames,             //The duration, in frames\n    type,                    //The easing type\n    loop,                    //Should the animation loop?\n    yoyo,                    //Should the direction reverse?\n    delayBeforeContinue      //Delay, in milliseconds, between sections\n  ) {\n\n    //Set defaults\n    if (totalFrames === undefined) totalFrames = 300;\n    if (type === undefined) type = \"smoothstep\";\n    if (loop === undefined) loop = false;\n    if (yoyo === undefined) yoyo = false;\n    if (delayBeforeContinue === undefined) delayBeforeContinue = 0;\n\n    //Divide the `totalFrames` into sections for each part of the path\n    var frames = totalFrames / pathArray.length;\n\n    //Set the current curve to 0, which will be the first one\n    var currentCurve = 0;\n\n    //Make the first path\n    var tween = makePath(currentCurve);\n\n    function makePath(currentCurve) {\n\n      //Use the custom `followCurve` function to make\n      //a sprite follow a curve\n      var tween = ga.followCurve(\n        sprite,\n        pathArray[currentCurve],\n        frames,\n        type\n      );\n\n      //When the tween is complete, advance the `currentCurve` by one.\n      //Add an optional delay between path segments, and then make the\n      //next path\n      tween.onComplete = function () {\n        currentCurve += 1;\n        if (currentCurve < pathArray.length) {\n          ga.wait(delayBeforeContinue, function () {\n            tween = makePath(currentCurve);\n          });\n        }\n\n        //If we've reached the end of the path, optionally\n        //loop and reverse it\n        else {\n          if (loop) {\n            if (yoyo) {\n\n              //Reverse order of the curves in the `pathArray` \n              pathArray.reverse();\n\n              //Reverse the order of the points in each curve\n              pathArray.forEach(function (curveArray) {\n                curveArray.reverse();\n              });\n            }\n\n            //After an optional delay, reset the sprite to the\n            //beginning of the path and make the next new path\n            ga.wait(delayBeforeContinue, function () {\n              currentCurve = 0;\n              sprite.x = pathArray[0][0];\n              sprite.y = pathArray[0][1];\n              tween = makePath(currentCurve);\n            });\n          }\n        }\n      };\n\n      //Return the path tween to the main function\n      return tween;\n    }\n\n    //Pass the tween back to the main program\n    return tween;\n  };\n\n\n  /*\n  Chapter 3: Sprite creation tools\n  --------------------------------\n  */\n\n  //### shoot\n\n  ga.shoot = function (\n    shooter, angle, offsetFromCenter,\n    bulletSpeed, bulletArray, bulletSprite) {\n    //Make a new sprite using the user-supplied `bulletSprite` function\n    var bullet = bulletSprite();\n\n    //Set the bullet's start point\n    bullet.x\n      = shooter.centerX - bullet.halfWidth\n      + (offsetFromCenter * Math.cos(angle));\n    bullet.y\n      = shooter.centerY - bullet.halfHeight\n      + (offsetFromCenter * Math.sin(angle));\n\n    //Set the bullet's velocity\n    bullet.vx = Math.cos(angle) * bulletSpeed;\n    bullet.vy = Math.sin(angle) * bulletSpeed;\n\n    //Push the bullet into the\n    bulletArray.push(bullet);\n    return bullet;\n  };\n\n\n  /*\n  ### grid\n  Create the grid of pegs using the `grid` function. `grid` returns a\n  `group` sprite object that contains a sprite for every cell in the\n  grid. You can define the rows and columns in the grid, whether or\n  not the sprites should be centered inside each cell, or what their offset from the\n  top left corner of each cell should be. Supply a function that\n  returns the sprite that you want to make for each cell. You can\n  supply an optional final function that runs any extra code after\n  each sprite has been created. Here's the format for creating a grid:\n\n          gridGroup = grid(\n\n            //Set the grid's properties\n            columns, rows, cellWidth, cellHeight,\n            areSpirtesCentered?, xOffset, yOffset,\n\n            //A function that returns a sprite\n            function() {return g.circle(16, \"blue\");},\n\n            //An optional final function that runs some extra code\n            function() {console.log(\"extra!\");}\n          );\n  */\n\n  ga.grid = function (\n    columns, rows, cellWidth, cellHeight,\n    centerCell, xOffset, yOffset,\n    makeSprite,\n    extra\n  ) {\n    //Set the defaults\n    if (columns === undefined) columns = 0;\n    if (rows === undefined) rows = 0;\n    if (cellWidth === undefined) cellWidth = 32;\n    if (cellHeight === undefined) cellHeight = 32;\n    if (xOffset === undefined) xOffset = 0;\n    if (yOffset === undefined) yOffset = 0;\n    if (centerCell === undefined) centerCell = false;\n\n    /*\n    if (!columns && columns !== 0) columns = 0;\n    if (!rows && rows !== 0) rows = 0;\n    if (!cellWidth && cellWidth !== 0) cellWidth = 32;\n    if (!cellHeight && cellHeight !== 0) cellHeight = 32;\n    if (!xOffset && xOffset !== 0) xOffset = 0;\n    if (!yOffset && yOffset !== 0) yOffset = 0;\n    centerCell = centerCell || false;\n    */\n\n    //Create an empty DisplayObjectContainer\n    var container = ga.group();\n\n    //The `create` method\n    container.createGrid = function () {\n      var length = columns * rows;\n      for (var i = 0; i < length; i++) {\n        var x = ((i % columns) * cellWidth),\n          y = (Math.floor(i / columns) * cellHeight);\n\n        //Use the `makeSprite` method supplied in the constructor\n        //to make a sprite for the grid cell\n        var sprite = makeSprite();\n        container.addChild(sprite);\n\n        //Should the sprite be centered in the cell?\n        if (!centerCell) {\n          sprite.x = x + xOffset;\n          sprite.y = y + yOffset;\n        }\n        else {\n          sprite.x = x + (cellWidth / 2) - sprite.halfWidth + xOffset;\n          sprite.y = y + (cellHeight / 2) - sprite.halfHeight + yOffset;\n        }\n\n        //Run any optional extra code. This calls the\n        //`extra` method supplied by the constructor\n        if (extra) extra(sprite);\n      }\n    };\n    container.createGrid();\n    ga.stage.addChild(container);\n    return container;\n  };\n\n  /*\n  ### progressBar\n  Use the `progressBar` to display the percentage of assetes being loaded.\n  To use it, first make sure you define a `load` state when you intialize Ga.\n  Here's an example of a Ga instance that's intialized with 5 assets. The last\n  argument, `load`, tells Ga that it should apply the `load` state as soon as\n  Ga starts.\n\n      var g = ga(\n        512, 512, setup,\n        [\n          \"images/blixyiiUI.png\",\n          \"images/blixyiiTileset.png\",\n          \"fonts/puzzler.otf\",\n          \"sounds/music.wav\",\n          \"sounds/bounce.wav\"\n        ],\n        load\n      );\n      g.start();\n\n  Next, create a `load` function. It will run in a loop while the assets are loading\n  and before the `setup` state is run. Here's how to create and update the progress\n  bar in the load state\n\n      function load() {\n        g.progressBar.create(g.canvas, g.assets);\n        g.progressBar.update();\n      }\n\n  When the assets have finished loading the `setup` state will automatically be run.\n  Remove the progress bar in the `setup` function state like this:\n\n      function setup() {\n        g.progressBar.remove();\n        //...\n      }\n\n  This is just a basic example of a progress bar to help you get started. You can use the\n  same format to create your own custom preloading animation.\n\n  */\n  ga.progressBar = {\n    maxWidth: 0,\n    height: 0,\n    backgroundColor: \"gray\",\n    foregroundColor: \"cyan\",\n    backBar: null,\n    frontBar: null,\n    percentage: null,\n    assets: null,\n    initialized: false,\n    create: function (canvas, assets) {\n      if (!this.initialized) {\n\n        //Store a reference to the `assets` object\n        this.assets = assets;\n\n        //Set the maximum width to half the width of the canvas\n        this.maxWidth = ga.canvas.width / 2;\n\n        //Build the progress bar using two Rectangle sprites and\n        //one Message Sprite\n        //1. Create the bar's gray background\n        this.backBar = ga.rectangle(this.maxWidth, 32, this.backgroundColor);\n        this.backBar.x = (ga.canvas.width / 2) - (this.maxWidth / 2);\n        this.backBar.y = (ga.canvas.height / 2) - 16;\n\n        //2. Create the blue foreground. This is the element of the\n        //progress bar that will increase in width as assets load\n        this.frontBar = ga.rectangle(this.maxWidth, 32, this.foregroundColor);\n        this.frontBar.x = (ga.canvas.width / 2) - (this.maxWidth / 2);\n        this.frontBar.y = (ga.canvas.height / 2) - 16;\n\n        //3. A text sprite that will display the percentage\n        //of assets that have loaded\n        this.percentage = ga.text(\"0%\", \"28px sans-serif\", \"black\");\n        this.percentage.x = (ga.canvas.width / 2) - (this.maxWidth / 2) + 12;\n        this.percentage.y = (ga.canvas.height / 2) - 12;\n\n        //Flag the progressBar as having been initialized\n        this.initialized = true;\n      }\n    },\n    update: function () {\n\n      //Change the width of the blue `frontBar` to match the\n      //ratio of assets that have loaded. Adding `+1` to\n      //`assets.loaded` means that the loading bar will appear at 100%\n      //when the last asset is being loaded, which is reassuring for the\n      //player observing the load progress\n      var ratio = (ga.assets.loaded + 1) / ga.assets.toLoad;\n      this.frontBar.width = this.maxWidth * ratio;\n\n\n      //Display the percentage\n      this.percentage.content = Math.floor((ratio) * 100) + \"%\";\n    },\n    remove: function () {\n\n      //Remove the progress bar\n      ga.remove(this.frontBar);\n      ga.remove(this.backBar);\n      ga.remove(this.percentage);\n    }\n  };\n\n  /*\n  particleEffect\n  -----\n\n  Create particles with a versatile function called function called\n  `particleEffect`. It's all you'll need for most 2D action games.\n  Here's an example of how to use it to \n  produce a starburst effect at the pointer's x and y position.\n\n      g.particleEffect(\n        g.pointer.x,                             //The particle’s starting x position\n        g.pointer.y,                             //The particle’s starting y position\n        function(){                              //Particle function\n          return g.sprite(\"images/star.png\");\n        },\n        20,                                      //Number of particles\n        0.1,                                     //Gravity\n        true,                                    //Random spacing\n        0, 6.28,                                 //Min/max angle\n        12, 24,                                  //Min/max size\n        1, 2,                                    //Min/max speed\n        0.005, 0.01,                             //Min/max scale speed\n        0.005, 0.01,                             //Min/max alpha speed\n        0.05, 0.1                                //Min/max rotation speed\n      );\n\n  You can see that most of those arguments describe range between \n  the minimum and maximum values that should be used to change \n  the sprites’ speed, rotation, scale and alpha.\n  You can also assign the number of particles that should be created,\n  and add optional gravity. \n\n  You can make particles using any sprites by customizing the third argument. \n  Just supply a function that returns the kind of sprite you want to use for each particle:\n\n      function(){                              \n        return g.sprite(\"images/star.png\");\n      },\n\n  If you supply a sprite that has multiple frames, the particleEffect \n  function will automatically choose a random frame for each particle.\n\n  The minimum and maximum angle values are important for defining the \n  circular spread of particles as they radiate out from the origin point. \n  For a completely circular explosion effect, use a minimum angle \n  of 0, and a maximum angle for 6.28.\n\n      0, 6.28\n\n  (These numbers values are radians; the equivalent in degrees is 0 and 360.) \n  0 starts at the 3 o’clock position, pointing directly to the right. 3.14 \n  is the 9 o’clock position, and 6.28 takes you around back to 0 again.\n\n  If you want to constrain the particles to a narrower angle range, just supply \n  the minimum and maximum values that describe that range. Here are values \n  you could use to constrain the angle to a pizza-slice with the crust pointing left.\n\n  2.4, 3.6\n\n  You could use a constrained angle range like this to create a particle stream, \n  like a fountain or rocket engine flames. By carefully choosing the sprite for \n  the particle and finely adjusting each parameter, you can use this \n  all-purpose `particleEffect` function to simulate everything from liquid to fire. \n  */\n\n  //First, you need an array to store the particles.\n  ga.particles = [];\n\n  ga.particleEffect = function (\n    x,\n    y,\n    spriteFunction,\n    numberOfParticles,\n    gravity,\n    randomSpacing,\n    minAngle, maxAngle,\n    minSize, maxSize,\n    minSpeed, maxSpeed,\n    minScaleSpeed, maxScaleSpeed,\n    minAlphaSpeed, maxAlphaSpeed,\n    minRotationSpeed, maxRotationSpeed\n  ) {\n\n    if (x === undefined) x = 0;\n    if (y === undefined) y = 0;\n    if (spriteFunction === undefined) spriteFunction = function () { return ga.circle(10, \"red\") };\n    if (numberOfParticles === undefined) numberOfParticles = 10;\n    if (gravity === undefined) gravity = 0;\n    if (randomSpacing === undefined) randomSpacing = true;\n    if (minAngle === undefined) minAngle = 0;\n    if (maxAngle === undefined) maxAngle = 6.28;\n    if (minSize === undefined) minSize = 4;\n    if (maxSize === undefined) maxSize = 16;\n    if (minSpeed === undefined) minSpeed = 0.1;\n    if (maxSpeed === undefined) maxSpeed = 1;\n    if (minScaleSpeed === undefined) minScaleSpeed = 0.01;\n    if (maxScaleSpeed === undefined) maxScaleSpeed = 0.05;\n    if (minAlphaSpeed === undefined) minAlphaSpeed = 0.02;\n    if (maxAlphaSpeed === undefined) maxAlphaSpeed = 0.02;\n    if (minRotationSpeed === undefined) minRotationSpeed = 0.01;\n    if (maxRotationSpeed === undefined) maxRotationSpeed = 0.03;\n\n    //`randomFloat` and `randomInt` helper functions\n    var randomFloat = function (min, max) { return min + Math.random() * (max - min) },\n      randomInt = function (min, max) { return Math.floor(Math.random() * (max - min + 1)) + min };\n\n    //An array to store the angles\n    var angles = [];\n\n    //A variable to store the current particle's angle\n    var angle;\n\n    //Figure out by how many radians each particle should be separated\n    var spacing = (maxAngle - minAngle) / (numberOfParticles - 1);\n\n    //Create an angle value for each particle and push that\n    //value into the `angles` array\n    for (var i = 0; i < numberOfParticles; i++) {\n\n      //If `randomSpacing` is `true`, give the particle any angle\n      //value between `minAngle` and `maxAngle`\n      if (randomSpacing) {\n        angle = randomFloat(minAngle, maxAngle);\n        angles.push(angle);\n      }\n\n      //If `randomSpacing` is `false`, space each particle evenly,\n      //starting with the `minAngle` and ending with the `maxAngle`\n      else {\n        if (angle === undefined) angle = minAngle;\n        angles.push(angle);\n        angle += spacing;\n      }\n    }\n\n    //Make a particle for each angle\n    angles.forEach(function (angle) {\n      makeParticle(angle)\n    });\n\n    //Make the particle\n    function makeParticle(angle) {\n\n      //Create the particle using the supplied sprite function\n      var particle = spriteFunction();\n\n      //Display a random frame if the particle has more than 1 frame\n      if (particle.frames.length > 0) {\n        particle.gotoAndStop(randomInt(0, particle.frames.length - 1));\n      }\n\n      //Set the x and y position\n      particle.x = x - particle.halfWidth;\n      particle.y = y - particle.halfHeight;\n\n      //Set a random width and height\n      var size = randomInt(minSize, maxSize);\n      particle.width = size;\n      particle.height = size;\n\n      //Set a random speed to change the scale, alpha and rotation\n      particle.scaleSpeed = randomFloat(minScaleSpeed, maxScaleSpeed);\n      particle.alphaSpeed = randomFloat(minAlphaSpeed, maxAlphaSpeed);\n      particle.rotationSpeed = randomFloat(minRotationSpeed, maxRotationSpeed);\n\n      //Set a random velocity at which the particle should move\n      var speed = randomFloat(minSpeed, maxSpeed);\n      particle.vx = speed * Math.cos(angle);\n      particle.vy = speed * Math.sin(angle);\n\n      //The particle's `update` method is called on each frame of the\n      //game loop\n      particle.updateParticle = function () {\n\n        //Add gravity\n        particle.vy += gravity;\n\n        //Move the particle\n        particle.x += particle.vx;\n        particle.y += particle.vy;\n\n        //Change the particle's `scale`\n        if (particle.scaleX - particle.scaleSpeed > 0) {\n          particle.scaleX -= particle.scaleSpeed;\n        }\n        if (particle.scaleY - particle.scaleSpeed > 0) {\n          particle.scaleY -= particle.scaleSpeed;\n        }\n\n        //Change the particle's rotation\n        particle.rotation += particle.rotationSpeed;\n\n        //Change the particle's `alpha`\n        particle.alpha -= particle.alphaSpeed;\n\n        //Remove the particle if its `alpha` reaches zero\n        if (particle.alpha <= 0) {\n          ga.remove(particle);\n          ga.particles.splice(ga.particles.indexOf(particle), 1);\n        }\n      };\n\n      //Push the particle into the `particles` array\n      //The `particles` array needs to be updated by the game loop each\n      //frame\n      ga.particles.push(particle);\n    }\n  }\n\n  //`updateParticles` loops through all the sprites in `ga.particles`\n  //and runs their `updateParticles` functions.\n  ga.updateParticles = function () {\n\n    //Update all the particles in the game.\n    if (ga.particles.length > 0) {\n      for (var i = ga.particles.length - 1; i >= 0; i--) {\n        var particle = ga.particles[i];\n        particle.updateParticle();\n      }\n    }\n  }\n\n  //Push `updateParticles` into the `ga.updateFunctions` array so that\n  //it runs inside Ga's game loop. (See the `ga.update` method in the \n  //`ga.js` file to see how this works.\n  ga.updateFunctions.push(ga.updateParticles);\n\n  /*\n  emitter\n  -------\n\n  Use the `emitter` function to create a constant stream of particles\n  at fixed intervals. The emitter is a simple timer that calls the \n  `particleEffect` function repeatedly at intervals in milliseconds that\n  you define. Use the emitter's `play` and `stop` methods to start and \n  stop the particle stream.\n\n  Here's how to use it to create particle emitter that emits star sprites\n  a 100ms intervals when the pointer is pressed:\n\n      //Create the emitter\n      var particleStream = g.emitter(\n        100,                                           //The interval\n        function(){\n          return g.particleEffect(                     //The particle function\n            g.pointer.x,                               //x position\n            g.pointer.y,                               //y position\n            function(){                                //Particle sprite\n              return g.sprite(\"images/star.png\");\n            }, \n            10,                                        //Number of particles\n            0.1,                                       //Gravity\n            false,                                     //Random spacing\n            3.14, 6.28,                                //Min/max angle\n            16, 32,                                    //Min/max size\n            2, 5                                       //Min/max speed\n          );\n        }\n      );\n\n      //Play the particle stream when the pointer is pressed\n      g.pointer.press = function(){\n        particleStream.play();\n        console.log(particleStream.playing)\n      };\n\n      //Stop the particle stream when the pointer is released\n      g.pointer.release = function(){\n        particleStream.stop();\n        console.log(particleStream.playing)\n      };\n  */\n\n  ga.emitter = function (interval, particleFunction) {\n    var emitter = {},\n      timerInterval = undefined;\n\n    emitter.playing = false;\n\n    function play() {\n      if (!emitter.playing) {\n        particleFunction();\n        timerInterval = setInterval(emitParticle.bind(this), interval);\n        emitter.playing = true;\n      }\n    }\n\n    function stop() {\n      if (emitter.playing) {\n        clearInterval(timerInterval);\n        emitter.playing = false;\n      }\n    }\n\n    function emitParticle() {\n      particleFunction();\n    }\n\n    emitter.play = play;\n    emitter.stop = stop;\n    return emitter;\n  }\n\n  /*\n  tilingSprite\n  ------------\n  Use a `tilingSprite` to create a seamless scrolling effect.\n  You could use it to create an infinite scrolling background.\n  Scroll the sprite's tile pattern using `tileX` and `tileY` properties.\n  For example, you could create a tiling sprite like this:\n\n      box = g.tilingSprite(128, 128, \"images/tile.png\");\n\n  Then in the game loop, scroll the x and y background position like this:\n\n      box.tileY += 1;\n      box.tileX += 1;\n      \n  The position of the box won't change, but the position of the image that it contains will.\n  \n  */\n\n  ga.tilingSprite = function (width, height, source, x, y) {\n\n    //Set the defaults.\n    if (x === undefined) x = 0;\n    if (y === undefined) y = 0;\n\n    //Figure out the tile's width and height.\n    var tileWidth, tileHeight;\n\n    //If the source is a texture atlas frame, use its\n    //`frame.w` and `frame.h` properties.\n    if (ga.assets[source].frame) {\n      tileWidth = ga.assets[source].frame.w;\n      tileHeight = ga.assets[source].frame.h;\n    }\n\n    //If it's an image, use the image's \n    //`width` and `height` properties.\n    else {\n      tileWidth = ga.assets[source].width;\n      tileHeight = ga.assets[source].height;\n    }\n\n    //Figure out the rows and columns.\n    //The number of rows and columns should always be\n    //one greater than the total number of tiles\n    //that can fit in the rectangle. This give us one \n    //additional row and column that we can reposition\n    //to create the infinite scroll effect.\n\n    var columns, rows;\n\n    //1. Columns\n    //If the width of the rectangle is greater than the width of the tile,\n    //calculate the number of tile columns.\n    if (width >= tileWidth) {\n      columns = Math.round(width / tileWidth) + 1;\n    }\n\n    //If the rectangle's width is less than the width of the\n    //tile, set the columns to 2, which is the minimum.\n    else {\n      columns = 2;\n    }\n\n    //2. Rows\n    //Calculate the tile rows in the same way.\n    if (height >= tileHeight) {\n      rows = Math.round(height / tileHeight) + 1;\n    } else {\n      rows = 2;\n    }\n\n    //Create a grid of sprites that's just one sprite larger\n    //than the `totalWidth` and `totalHeight`.\n    var tileGrid = ga.grid(\n      columns, rows, tileWidth, tileHeight, false, 0, 0,\n      function () {\n\n        //Make a sprite from the supplied `source`.\n        var tile = ga.sprite(source);\n        return tile;\n      }\n    );\n\n    //Declare the grid's private properties that we'll use to\n    //help scroll the tiling background.\n    tileGrid._tileX = 0;\n    tileGrid._tileY = 0;\n\n    //Create an empty rectangle sprite without a fill or stoke color.\n    //Set it to the supplied `width` and `height`.\n    var container = ga.rectangle(width, height, \"none\", \"none\");\n    container.x = x;\n    container.y = y;\n\n    //Set the rectangle's `mask` property to `true`. This switches on `ctx.clip()`\n    //In the rectangle sprite's `render` method.\n    container.mask = true;\n\n    //Add the tile grid to the rectangle container.\n    container.addChild(tileGrid);\n\n    //Define the `tileX` and `tileY` properties on the parent container\n    //so that you can scroll the tiling background.\n    Object.defineProperties(container, {\n      tileX: {\n        get: function () {\n          return tileGrid._tileX;\n        },\n\n        set: function (value) {\n\n          //Loop through all of the grid's child sprites.\n          tileGrid.children.forEach(function (child) {\n\n            //Figure out the difference between the new position\n            //and the previous position.\n            var difference = value - tileGrid._tileX;\n\n            //Offset the child sprite by the difference.\n            child.x += difference;\n\n            //If the x position of the sprite exceeds the total width\n            //of the visible columns, reposition it to just in front of the \n            //left edge of the container. This creates the wrapping\n            //effect.\n            if (child.x > (columns - 1) * tileWidth) {\n              child.x = 0 - tileWidth + difference;\n            }\n\n            //Use the same procedure to wrap sprites that \n            //exceed the left boundary.\n            if (child.x < 0 - tileWidth - difference) {\n              child.x = (columns - 1) * tileWidth;\n            }\n          });\n\n          //Set the private `_tileX` property to the new value.\n          tileGrid._tileX = value;\n        },\n        enumerable: true, configurable: true\n      },\n      tileY: {\n        get: function () {\n          return tileGrid._tileY;\n        },\n\n        //Follow the same format to wrap sprites on the y axis.\n        set: function (value) {\n          tileGrid.children.forEach(function (child) {\n            var difference = value - tileGrid._tileY;\n            child.y += difference;\n            if (child.y > (rows - 1) * tileHeight) child.y = 0 - tileHeight + difference;\n            if (child.y < 0 - tileHeight - difference) child.y = (rows - 1) * tileHeight;\n          });\n          tileGrid._tileY = value;\n        },\n        enumerable: true, configurable: true\n      }\n    });\n\n    //Return the rectangle container.\n    return container;\n  }\n\n\n  /*\n  Chapter 4: Collision\n  --------------------\n  */\n\n  /*\n  ### Boundary collisions\n  */\n\n  //#### outsideBounds\n  ga.outsideBounds = function (s, bounds, extra) {\n\n    var x = bounds.x,\n      y = bounds.y,\n      width = bounds.width,\n      height = bounds.height;\n\n    //The `collision` object is used to store which\n    //side of the containing rectangle the sprite hits\n    var collision;\n\n    //Left\n    if (s.x < x - s.width) {\n      collision = \"left\";\n    }\n    //Top\n    if (s.y < y - s.height) {\n      collision = \"top\";\n    }\n    //Right\n    if (s.x > width) {\n      collision = \"right\";\n    }\n    //Bottom\n    if (s.y > height) {\n      collision = \"bottom\";\n    }\n\n    //The `extra` function runs if there was a collision\n    //and `extra` has been defined\n    if (collision && extra) extra(collision);\n\n    //Return the `collision` object\n    return collision;\n  };\n\n  //#### contain\n  ga.contain = function (s, bounds, bounce, extra) {\n\n    var x = bounds.x,\n      y = bounds.y,\n      width = bounds.width,\n      height = bounds.height;\n\n    //Set `bounce` to `false` by default\n    bounce = bounce || false;\n\n    //The `collision` object is used to store which\n    //side of the containing rectangle the sprite hits\n    var collision;\n\n    //Left\n    if (s.x < x) {\n\n      //Bounce the sprite if `bounce` is true\n      if (bounce) s.vx *= -1;\n\n      //If the sprite has `mass`, let the mass\n      //affect the sprite's velocity\n      if (s.mass) s.vx /= s.mass;\n      s.x = x;\n      collision = \"left\";\n    }\n\n    //Top\n    if (s.y < y) {\n      if (bounce) s.vy *= -1;\n      if (s.mass) s.vy /= s.mass;\n      s.y = y;\n      collision = \"top\";\n    }\n\n    //Right\n    if (s.x + s.width > width) {\n      if (bounce) s.vx *= -1;\n      if (s.mass) s.vx /= s.mass;\n      s.x = width - s.width;\n      collision = \"right\";\n    }\n\n    //Bottom\n    if (s.y + s.height > height) {\n      if (bounce) s.vy *= -1;\n      if (s.mass) s.vy /= s.mass;\n      s.y = height - s.height;\n      collision = \"bottom\";\n    }\n\n    //The `extra` function runs if there was a collision\n    //and `extra` has been defined\n    if (collision && extra) extra(collision);\n\n    //Return the `collision` object\n    return collision;\n  };\n\n  /*\n  ### Shape collisions\n  /\n\n\n  /*\n  #### hitTestPoint\n\n  Use it to find out if a point is touching a circular or rectangular sprite.\n  Parameters:\n  a. An object with `x` and `y` properties.\n  b. A sprite object with `x`, `y`, `centerX` and `centerY` properties.\n  If the sprite has a `radius` property, the function will interpret\n  the shape as a circle.\n  */\n\n  ga.hitTestPoint = function (point, sprite) {\n\n    var shape, left, right, top, bottom, vx, vy, magnitude, hit;\n\n    //Find out if the sprite is rectangular or circular depending\n    //on whether it has a `radius` property\n    if (sprite.radius) {\n      shape = \"circle\";\n    } else {\n      shape = \"rectangle\";\n    }\n\n    //Rectangle\n    if (shape === \"rectangle\") {\n\n      //Get the position of the sprite's edges\n      left = sprite.x;\n      right = sprite.x + sprite.width;\n      top = sprite.y;\n      bottom = sprite.y + sprite.height;\n\n      //Find out if the point is intersecting the rectangle\n      hit = point.x > left && point.x < right && point.y > top && point.y < bottom;\n    }\n\n    //Circle\n    if (shape === \"circle\") {\n\n      //Find the distance between the point and the\n      //center of the circle\n      vx = point.x - sprite.centerX,\n        vy = point.y - sprite.centerY,\n        magnitude = Math.sqrt(vx * vx + vy * vy);\n\n      //The point is intersecting the circle if the magnitude\n      //(distance) is less than the circle's radius\n      hit = magnitude < sprite.radius;\n    }\n\n    //`hit` will be either `true` or `false`\n    return hit;\n  };\n\n  /*\n  #### hitTestCircle\n\n  Use it to find out if two circular sprites are touching.\n  Parameters:\n  a. A sprite object with `centerX`, `centerY` and `radius` properties.\n  b. A sprite object with `centerX`, `centerY` and `radius`.\n  */\n\n  ga.hitTestCircle = function (c1, c2, global) {\n    var vx, vy, magnitude, totalRadii, hit;\n\n    //Set `global` to a default value of `false`\n    if (global === undefined) global = false;\n\n    //Calculate the vector between the circles’ center points\n    if (global) {\n\n      //Use global coordinates\n      vx = (c2.gx + c2.radius) - (c1.gx + c1.radius);\n      vy = (c2.gy + c2.radius) - (c1.gy + c1.radius);\n    } else {\n\n      //Use local coordinates\n      vx = c2.centerX - c1.centerX;\n      vy = c2.centerY - c1.centerY;\n    }\n\n    //Find the distance between the circles by calculating\n    //the vector's magnitude (how long the vector is)\n    magnitude = Math.sqrt(vx * vx + vy * vy);\n\n    //Add together the circles' total radii\n    totalRadii = c1.radius + c2.radius;\n\n    //Set hit to true if the distance between the circles is\n    //less than their totalRadii\n    hit = magnitude < totalRadii;\n\n    //`hit` will be either `true` or `false`\n    return hit;\n  };\n\n  /*\n  #### hitTestRectangle\n\n  Use it to find out if two rectangular sprites are touching.\n  Parameters:\n  a. A sprite object with `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\n  b. A sprite object with `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\n\n  */\n\n  ga.hitTestRectangle = function (r1, r2, global) {\n    var hit, combinedHalfWidths, combinedHalfHeights, vx, vy;\n\n    //Set `global` to a default value of `false`\n    if (global === undefined) global = false;\n\n    //A variable to determine whether there's a collision\n    hit = false;\n\n    //Calculate the distance vector\n    if (global) {\n      vx = (r1.gx + r1.halfWidth) - (r2.gx + r2.halfWidth);\n      vy = (r1.gy + r1.halfHeight) - (r2.gy + r2.halfHeight);\n    } else {\n      vx = r1.centerX - r2.centerX;\n      vy = r1.centerY - r2.centerY;\n    }\n\n    //Figure out the combined half-widths and half-heights\n    combinedHalfWidths = r1.halfWidth + r2.halfWidth;\n    combinedHalfHeights = r1.halfHeight + r2.halfHeight;\n\n    //Check for a collision on the x axis\n    if (Math.abs(vx) < combinedHalfWidths) {\n\n      //A collision might be occuring. Check for a collision on the y axis\n      if (Math.abs(vy) < combinedHalfHeights) {\n\n        //There's definitely a collision happening\n        hit = true;\n      } else {\n\n        //There's no collision on the y axis\n        hit = false;\n      }\n    } else {\n\n      //There's no collision on the x axis\n      hit = false;\n    }\n\n    //`hit` will be either `true` or `false`\n    return hit;\n  };\n\n  /*\n   hitTestCircleRectangle\n   ----------------\n \n   Use it to find out if a circular shape is touching a rectangular shape\n   Parameters: \n   a. A sprite object with `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\n   b. A sprite object with `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\n \n   */\n\n  ga.hitTestCircleRectangle = function (c1, r1, global) {\n\n    var region, collision, c1x, c1y, r1x, r1y;\n\n    //Set `global` to a default value of `false`\n    if (global === undefined) global = false;\n\n    //Use either global or local coordinates\n    if (global) {\n      c1x = c1.gx;\n      c1y = c1.gy\n      r1x = r1.gx;\n      r1y = r1.gy;\n    } else {\n      c1x = c1.x;\n      c1y = c1.y\n      r1x = r1.x;\n      r1y = r1.y;\n    }\n\n    //Is the circle above the rectangle's top edge?\n    if (c1y < r1y - r1.halfHeight) {\n\n      //If it is, we need to check whether it's in the \n      //top left, top center or top right\n      //(Increasing the size of the region by 2 pixels slightly weights\n      //the text in favor of a rectangle vs. rectangle collision test.\n      //This gives a more natural looking result with corner collisions\n      //when physics is added)\n      if (c1x < r1x - 1 - r1.halfWidth) {\n        region = \"topLeft\";\n      }\n      else if (c1x > r1x + 1 + r1.halfWidth) {\n        region = \"topRight\";\n      }\n      else {\n        region = \"topMiddle\";\n      }\n    }\n\n    //The circle isn't above the top edge, so it might be\n    //below the bottom edge\n    else if (c1y > r1y + r1.halfHeight) {\n\n      //If it is, we need to check whether it's in the bottom left,\n      //bottom center, or bottom right\n      if (c1x < r1x - 1 - r1.halfWidth) {\n        region = \"bottomLeft\";\n      }\n      else if (c1x > r1x + 1 + r1.halfWidth) {\n        region = \"bottomRight\";\n      }\n      else {\n        region = \"bottomMiddle\";\n      }\n    }\n\n    //The circle isn't above the top edge or below the bottom edge,\n    //so it must be on the left or right side\n    else {\n      if (c1x < r1x - r1.halfWidth) {\n        region = \"leftMiddle\";\n      }\n      else {\n        region = \"rightMiddle\";\n      }\n    }\n\n    //Is this the circle touching the flat sides\n    //of the rectangle?\n    if (region === \"topMiddle\"\n      || region === \"bottomMiddle\"\n      || region === \"leftMiddle\"\n      || region === \"rightMiddle\") {\n\n      //Yes, it is, so do a standard rectangle vs. rectangle collision test\n      collision = ga.hitTestRectangle(c1, r1, global);\n    }\n\n    //The circle is touching one of the corners, so do a\n    //circle vs. point collision test\n    else {\n      var point = {};\n\n      switch (region) {\n        case \"topLeft\":\n          point.x = r1x;\n          point.y = r1y;\n          break;\n\n        case \"topRight\":\n          point.x = r1x + r1.width;\n          point.y = r1y;\n          break;\n\n        case \"bottomLeft\":\n          point.x = r1x;\n          point.y = r1y + r1.height;\n          break;\n\n        case \"bottomRight\":\n          point.x = r1x + r1.width;\n          point.y = r1y + r1.height;\n      }\n\n      //Check for a collision between the circle and the point\n      collision = ga.hitTestCirclePoint(c1, point, global);\n    }\n\n    //Return the result of the collision.\n    //The return value will be `undefined` if there's no collision\n    if (collision) {\n      return region;\n    } else {\n      return collision;\n    }\n  };\n\n  /*\n  hitTestCirclePoint\n  ------------------\n\n  Use it to find out if a circular shape is touching a point\n  Parameters: \n  a. A sprite object with `centerX`, `centerY`, and `radius` properties.\n  b. A point object with `x` and `y` properties.\n\n  */\n\n  ga.hitTestCirclePoint = function (c1, point, global) {\n\n    //Set `global` to a default value of `false`\n    if (global === undefined) global = false;\n\n    //A point is just a circle with a diameter of\n    //1 pixel, so we can cheat. All we need to do is an ordinary circle vs. circle\n    //Collision test. Just supply the point with the properties\n    //it needs\n    point.diameter = 1;\n    point.radius = 0.5;\n    point.centerX = point.x;\n    point.centerY = point.y;\n    point.gx = point.x;\n    point.gy = point.y;\n    return ga.hitTestCircle(c1, point, global);\n  };\n\n  /*\n  #### rectangleCollision\n\n  Use it to prevent two rectangular sprites from overlapping.\n  Optionally, make the first retangle bounceoff the second rectangle.\n  Parameters:\n  a. A sprite object with `x`, `y` `center.x`, `center.y`, `halfWidth` and `halfHeight` properties.\n  b. A sprite object with `x`, `y` `center.x`, `center.y`, `halfWidth` and `halfHeight` properties.\n  c. Optional: true or false to indicate whether or not the first sprite\n  should bounce off the second sprite.\n  */\n\n  ga.rectangleCollision = function (r1, r2, bounce, global) {\n    var collision, combinedHalfWidths, combinedHalfHeights,\n      overlapX, overlapY, vx, vy;\n\n    //Set `bounce` to a default value of `true`\n    if (bounce === undefined) bounce = false;\n\n    //Set `global` to a default value of `false`\n    if (global === undefined) global = false;\n\n    //Calculate the distance vector\n    if (global) {\n      vx = (r1.gx + r1.halfWidth) - (r2.gx + r2.halfWidth);\n      vy = (r1.gy + r1.halfHeight) - (r2.gy + r2.halfHeight);\n    } else {\n      vx = r1.centerX - r2.centerX;\n      vy = r1.centerY - r2.centerY;\n    }\n\n    //Figure out the combined half-widths and half-heights\n    combinedHalfWidths = r1.halfWidth + r2.halfWidth;\n    combinedHalfHeights = r1.halfHeight + r2.halfHeight;\n\n    //Check whether vx is less than the combined half widths\n    if (Math.abs(vx) < combinedHalfWidths) {\n\n      //A collision might be occurring!\n      //Check whether vy is less than the combined half heights\n      if (Math.abs(vy) < combinedHalfHeights) {\n\n        //A collision has occurred! This is good!\n        //Find out the size of the overlap on both the X and Y axes\n        overlapX = combinedHalfWidths - Math.abs(vx);\n        overlapY = combinedHalfHeights - Math.abs(vy);\n\n        //The collision has occurred on the axis with the\n        //*smallest* amount of overlap. Let's figure out which\n        //axis that is\n\n        if (overlapX >= overlapY) {\n\n          //The collision is happening on the X axis\n          //But on which side? vy can tell us\n          if (vy > 0) {\n            collision = \"top\";\n\n            //Move the rectangle out of the collision\n            r1.y = r1.y + overlapY;\n          } else {\n            collision = \"bottom\";\n\n            //Move the rectangle out of the collision\n            r1.y = r1.y - overlapY;\n          }\n          //Bounce\n          if (bounce) {\n            r1.vy *= -1;\n\n            /*Alternative\n            //Find the bounce surface's vx and vy properties\n            var s = {};\n            s.vx = r2.x - r2.x + r2.width;\n            s.vy = 0;\n\n            //Bounce r1 off the surface\n            //bounceOffSurface(r1, s);\n            */\n          }\n        } else {\n\n          //The collision is happening on the Y axis\n          //But on which side? vx can tell us\n          if (vx > 0) {\n            collision = \"left\";\n\n            //Move the rectangle out of the collision\n            r1.x = r1.x + overlapX;\n          } else {\n            collision = \"right\";\n\n            //Move the rectangle out of the collision\n            r1.x = r1.x - overlapX;\n          }\n\n          //Bounce\n          if (bounce) {\n            r1.vx *= -1;\n\n            /*Alternative\n            //Find the bounce surface's vx and vy properties\n            var s = {};\n            s.vx = 0;\n            s.vy = r2.y - r2.y + r2.height;\n\n            //Bounce r1 off the surface\n            bounceOffSurface(r1, s);\n            */\n          }\n        }\n      } else {\n\n        //No collision\n      }\n    } else {\n\n      //No collision\n    }\n\n    //Return the collision string. it will be either \"top\", \"right\",\n    //\"bottom\", or \"left\" depening on which side of r1 is touching r2.\n    return collision;\n  }\n\n  /*\n  #### circleCollision\n\n  Use this function to prevent a moving circular sprite from overlapping and optionally\n  bouncing off a non-moving circular sprite.\n  Parameters:\n  a. A sprite object with `x`, `y` `centerX`, `centerY` and `radius` properties.\n  b. A sprite object with `x`, `y` `centerX`, `centerY` and `radius` properties.\n  c. Optional: `true` or `false` to indicate whether or not the first sprite\n  d. Optional: `true` or `false` to indicate whether or not local or global sprite positions should be used.\n  This defaults to `true` so set it to `false` if you want to use the sprite's local coordinates.\n  should bounce off the second sprite.\n  The sprites can contain an optional mass property that should be greater than 1.\n\n  */\n\n  ga.circleCollision = function (c1, c2, bounce, global) {\n    var magnitude, combinedRadii, overlap,\n      vx, vy, dx, dy, s = {},\n      hit = false;\n\n    //Set `bounce` to a default value of `true`\n    if (bounce === undefined) bounce = true;\n\n    //Set `global` to a default value of `false`\n    if (global === undefined) global = false;\n\n    //Calculate the vector between the circles’ center points\n\n    if (global) {\n\n      //Use global coordinates\n      vx = (c2.gx + c2.radius) - (c1.gx + c1.radius);\n      vy = (c2.gy + c2.radius) - (c1.gy + c1.radius);\n    } else {\n\n      //Use local coordinates\n      vx = c2.centerX - c1.centerX;\n      vy = c2.centerY - c1.centerY;\n    }\n\n    //Find the distance between the circles by calculating\n    //the vector's magnitude (how long the vector is)\n    magnitude = Math.sqrt(vx * vx + vy * vy);\n\n    //Add together the circles' combined half-widths\n    combinedRadii = c1.radius + c2.radius;\n\n    //Figure out if there's a collision\n    if (magnitude < combinedRadii) {\n\n      //Yes, a collision is happening.\n      hit = true;\n\n      //Find the amount of overlap between the circles\n      overlap = combinedRadii - magnitude;\n\n      //Add some \"quantum padding\". This adds a tiny amount of space\n      //between the circles to reduce their surface tension and make\n      //them more slippery. \"0.3\" is a good place to start but you might\n      //need to modify this slightly depending on the exact behaviour\n      //you want. Too little and the balls will feel sticky, too much\n      //and they could start to jitter if they're jammed together\n      var quantumPadding = 0.3;\n      overlap += quantumPadding;\n\n      //Normalize the vector.\n      //These numbers tell us the direction of the collision\n      dx = vx / magnitude;\n      dy = vy / magnitude;\n\n      //Move circle 1 out of the collision by multiplying\n      //the overlap with the normalized vector and subtract it from\n      //circle 1's position\n      c1.x -= overlap * dx;\n      c1.y -= overlap * dy;\n\n      //Bounce\n      if (bounce) {\n        //Create a collision vector object, `s` to represent the bounce surface.\n        //Find the bounce surface's x and y properties\n        //(This represents the normal of the distance vector between the circles)\n        s.x = vy;\n        s.y = -vx;\n\n        //Bounce c1 off the surface\n        bounceOffSurface(c1, s);\n      } else {\n        /*\n        //Make it a bit slippery\n        var friction = 0.9;\n        c1.vx *= friction;\n        c1.vy *= friction;\n        */\n      }\n    }\n\n    return hit;\n  };\n\n  /*\n  #### movingCircleCollision\n\n  Use it to make two moving circles bounce off each other.\n  Parameters:\n  a. A sprite object with `x`, `y` `centerX`, `centerY` and `radius` properties.\n  b. A sprite object with `x`, `y` `centerX`, `centerY` and `radius` properties.\n  The sprites can contain an optional mass property that should be greater than 1.\n\n  */\n\n  ga.movingCircleCollision = function (c1, c2, global) {\n    var combinedRadii, overlap, xSide, ySide,\n      //`s` refers to the collision surface\n      s = {},\n      p1A = {}, p1B = {}, p2A = {}, p2B = {},\n      hit = false;\n\n    //Apply mass, if the circles have mass properties\n    c1.mass = c1.mass || 1;\n    c2.mass = c2.mass || 1;\n\n    //Set `global` to a default value of `false`\n    if (global === undefined) global = false;\n\n    //Calculate the vector between the circles’ center points\n    if (global) {\n\n      //Use global coordinates\n      s.vx = (c2.gx + c2.radius) - (c1.gx + c1.radius);\n      s.vy = (c2.gy + c2.radius) - (c1.gy + c1.radius);\n    } else {\n\n      //Use local coordinates\n      s.vx = c2.centerX - c1.centerX;\n      s.vy = c2.centerY - c1.centerY;\n    }\n\n    //Find the distance between the circles by calculating\n    //the vector's magnitude (how long the vector is)\n    s.magnitude = Math.sqrt(s.vx * s.vx + s.vy * s.vy);\n\n    //Add together the circles' combined half-widths\n    combinedRadii = c1.radius + c2.radius;\n\n    //Figure out if there's a collision\n    if (s.magnitude < combinedRadii) {\n\n      //Yes, a collision is happening\n      hit = true;\n\n      //Find the amount of overlap between the circles\n      overlap = combinedRadii - s.magnitude;\n\n      //Add some \"quantum padding\" to the overlap\n      overlap += 0.3;\n\n      //Normalize the vector.\n      //These numbers tell us the direction of the collision\n      s.dx = s.vx / s.magnitude;\n      s.dy = s.vy / s.magnitude;\n\n      //Find the collision vector.\n      //Divide it in half to share between the circles, and make it absolute\n      s.vxHalf = Math.abs(s.dx * overlap / 2);\n      s.vyHalf = Math.abs(s.dy * overlap / 2);\n\n      //Find the side that the collision if occurring on\n      (c1.x > c2.x) ? xSide = 1 : xSide = -1;\n      (c1.y > c2.y) ? ySide = 1 : ySide = -1;\n\n      //Move c1 out of the collision by multiplying\n      //the overlap with the normalized vector and adding it to\n      //the circle's positions\n      c1.x = c1.x + (s.vxHalf * xSide);\n      c1.y = c1.y + (s.vyHalf * ySide);\n\n      //Move c2 out of the collision\n      c2.x = c2.x + (s.vxHalf * -xSide);\n      c2.y = c2.y + (s.vyHalf * -ySide);\n\n      //1. Calculate the collision surface's properties\n\n      //Find the surface vector's left normal\n      s.lx = s.vy;\n      s.ly = -s.vx;\n\n      //2. Bounce c1 off the surface (s)\n\n      //Find the dot product between c1 and the surface\n      var dp1 = c1.vx * s.dx + c1.vy * s.dy;\n\n      //Project c1's velocity onto the collision surface\n      p1A.x = dp1 * s.dx;\n      p1A.y = dp1 * s.dy;\n\n      //Find the dot product of c1 and the surface's left normal (s.l.x and s.l.y)\n      var dp2 = c1.vx * (s.lx / s.magnitude) + c1.vy * (s.ly / s.magnitude);\n\n      //Project the c1's velocity onto the surface's left normal\n      p1B.x = dp2 * (s.lx / s.magnitude);\n      p1B.y = dp2 * (s.ly / s.magnitude);\n\n      //3. Bounce c2 off the surface (s)\n\n      //Find the dot product between c2 and the surface\n      var dp3 = c2.vx * s.dx + c2.vy * s.dy;\n\n      //Project c2's velocity onto the collision surface\n      p2A.x = dp3 * s.dx;\n      p2A.y = dp3 * s.dy;\n\n      //Find the dot product of c2 and the surface's left normal (s.l.x and s.l.y)\n      var dp4 = c2.vx * (s.lx / s.magnitude) + c2.vy * (s.ly / s.magnitude);\n\n      //Project c2's velocity onto the surface's left normal\n      p2B.x = dp4 * (s.lx / s.magnitude);\n      p2B.y = dp4 * (s.ly / s.magnitude);\n\n      //Calculate the bounce vectors\n      //Bounce c1\n      //using p1B and p2A\n      c1.bounce = {};\n      c1.bounce.x = p1B.x + p2A.x;\n      c1.bounce.y = p1B.y + p2A.y;\n\n      //Bounce c2\n      //using p1A and p2B\n      c2.bounce = {};\n      c2.bounce.x = p1A.x + p2B.x;\n      c2.bounce.y = p1A.y + p2B.y;\n\n      //Add the bounce vector to the circles' velocity\n      //and add mass if the circle has a mass property\n      c1.vx = c1.bounce.x / c1.mass;\n      c1.vy = c1.bounce.y / c1.mass;\n      c2.vx = c2.bounce.x / c2.mass;\n      c2.vy = c2.bounce.y / c2.mass;\n    }\n    return hit;\n  };\n\n  //#### multipleCircleCollision\n  /*\n  Checks all the circles in an array for a collision against\n  all the other circles in an array, using `movingCircleCollision` (above)\n  */\n\n  ga.multipleCircleCollision = function (arrayOfCircles, global) {\n\n    //Set `global` to a default value of `false`\n    if (global === undefined) global = false;\n\n    //marble collisions\n    for (var i = 0; i < arrayOfCircles.length; i++) {\n\n      //The first marble to use in the collision check\n      var c1 = arrayOfCircles[i];\n      for (var j = i + 1; j < arrayOfCircles.length; j++) {\n\n        //The second marble to use in the collision check\n        var c2 = arrayOfCircles[j];\n\n        //Check for a collision and bounce the marbles apart if\n        //they collide. Use an optional mass property on the sprite\n        //to affect the bounciness of each marble\n        ga.movingCircleCollision(c1, c2, global);\n      }\n    }\n  };\n\n  /*\n  circlePointCollision\n  --------------------\n\n  Use it to bounce a circular sprite off a point.\n  Parameters: \n  a. A sprite object with `centerX`, `centerY`, and `radius` properties.\n  b. A point object with `x` and `y` properties.\n\n  */\n\n  ga.circlePointCollision = function (c1, point, bounce, global) {\n\n    //Set `global` and `bounce` to a default values of `false`\n    if (global === undefined) global = false;\n    if (bounce === undefined) bounce = false;\n\n    //A point is just a circle with a diameter of\n    //1 pixel, so we can cheat. All we need to do is an ordinary circle vs. circle\n    //Collision test. Just supply the point with the properties\n    //it needs\n    point.diameter = 1;\n    point.radius = 0.5;\n    point.centerX = point.x;\n    point.centerY = point.y;\n    point.gx = point.x;\n    point.gy = point.y;\n    return ga.circleCollision(c1, point, bounce, global);\n  }\n\n  /*\n  circleRectangleCollision\n  ------------------------\n\n  Use it to bounce a circular shape off a rectangular shape\n  Parameters: \n  a. A sprite object with `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\n  b. A sprite object with `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\n\n  */\n\n  ga.circleRectangleCollision = function (c1, r1, bounce, global) {\n\n    var region, collision, c1x, c1y, r1x, r1y;\n\n    //Set `global` and `bounce` to a default values of `false`\n    if (global === undefined) global = false;\n    if (bounce === undefined) bounce = false;\n\n    //Use either the global or local coordinates\n    if (global) {\n      c1x = c1.gx;\n      c1y = c1.gy\n      r1x = r1.gx;\n      r1y = r1.gy;\n    } else {\n      c1x = c1.x;\n      c1y = c1.y\n      r1x = r1.x;\n      r1y = r1.y;\n    }\n\n    //Is the circle above the rectangle's top edge?\n    if (c1y < r1y - r1.halfHeight) {\n\n      //If it is, we need to check whether it's in the \n      //top left, top center or top right\n      if (c1x < r1x - 1 - r1.halfWidth) {\n        region = \"topLeft\";\n      }\n      else if (c1x > r1x + 1 + r1.halfWidth) {\n        region = \"topRight\";\n      }\n      else {\n        region = \"topMiddle\";\n      }\n    }\n\n    //The circle isn't above the top edge, so it might be\n    //below the bottom edge\n    else if (c1y > r1y + r1.halfHeight) {\n\n      //If it is, we need to check whether it's in the bottom left,\n      //bottom center, or bottom right\n      if (c1x < r1x - 1 - r1.halfWidth) {\n        region = \"bottomLeft\";\n      }\n      else if (c1x > r1x + 1 + r1.halfWidth) {\n        region = \"bottomRight\";\n      }\n      else {\n        region = \"bottomMiddle\";\n      }\n    }\n\n    //The circle isn't above the top edge or below the bottom edge,\n    //so it must be on the left or right side\n    else {\n      if (c1x < r1x - r1.halfWidth) {\n        region = \"leftMiddle\";\n      }\n      else {\n        region = \"rightMiddle\";\n      }\n    }\n\n    //Is this the circle touching the flat sides\n    //of the rectangle?\n    if (region === \"topMiddle\"\n      || region === \"bottomMiddle\"\n      || region === \"leftMiddle\"\n      || region === \"rightMiddle\") {\n\n      //Yes, it is, so do a standard rectangle vs. rectangle collision test\n      collision = ga.rectangleCollision(c1, r1, bounce, global);\n    }\n\n    //The circle is touching one of the corners, so do a\n    //circle vs. point collision test\n    else {\n      var point = {};\n\n      switch (region) {\n        case \"topLeft\":\n          point.x = r1x;\n          point.y = r1y;\n          break;\n\n        case \"topRight\":\n          point.x = r1x + r1.width;\n          point.y = r1y;\n          break;\n\n        case \"bottomLeft\":\n          point.x = r1x;\n          point.y = r1y + r1.height;\n          break;\n\n        case \"bottomRight\":\n          point.x = r1x + r1.width;\n          point.y = r1y + r1.height;\n      }\n\n      //Check for a collision between the circle and the point\n      collision = ga.circlePointCollision(c1, point, bounce, global);\n    }\n\n    if (collision) {\n      return region;\n    } else {\n      return collision;\n    }\n  }\n\n  /*\n  #### bounceOffSurface\n\n  Use this to bounce an object off another object. It's only used by the other collision functions,\n  so you don't need to call it yourself.\n  Parameters:\n  a. An object with `vx` and `vy` properties. This represents the object that is colliding\n  with a surface.\n  b. An object with `x` and `y` properties. This represents the surface that the object\n  is colliding into.\n  The first object can optionally have a mass property that's greater than 1. The mass will\n  be used to dampen the bounce effect.\n  */\n\n  function bounceOffSurface(o, s) {\n    var dp1, dp2,\n      p1 = {},\n      p2 = {},\n      bounce = {},\n      mass = o.mass || 1;\n\n    //1. Calculate the collision surface's properties\n    //Find the surface vector's left normal\n    s.lx = s.y;\n    s.ly = -s.x;\n\n    //Find its magnitude\n    s.magnitude = Math.sqrt(s.x * s.x + s.y * s.y);\n\n    //Find its normalized values\n    s.dx = s.x / s.magnitude;\n    s.dy = s.y / s.magnitude;\n\n    //2. Bounce the object (o) off the surface (s)\n\n    //Find the dot product between the object and the surface\n    dp1 = o.vx * s.dx + o.vy * s.dy;\n\n    //Project the object's velocity onto the collision surface\n    p1.vx = dp1 * s.dx;\n    p1.vy = dp1 * s.dy;\n\n    //Find the dot product of the object and the surface's left normal (s.l.x and s.l.y)\n    dp2 = o.vx * (s.lx / s.magnitude) + o.vy * (s.ly / s.magnitude);\n\n    //Project the object's velocity onto the surface's left normal\n    p2.vx = dp2 * (s.lx / s.magnitude);\n    p2.vy = dp2 * (s.ly / s.magnitude);\n\n    //Reverse the projection on the surface's left normal\n    p2.vx *= -1;\n    p2.vy *= -1;\n\n    //Add up the projections to create a new bounce vector\n    bounce.x = p1.vx + p2.vx;\n    bounce.y = p1.vy + p2.vy;\n\n    //Assign the bounce vector to the object's velocity\n    //with optional mass to dampen the effect\n    o.vx = bounce.x / mass;\n    o.vy = bounce.y / mass;\n  }\n\n  /*\n  //#### hit\n  An universal collision method that works for rectangular and circular sprites.\n  it figures out what kinds of sprites are involved in the collision and\n  automatically chooses the correct collision method.\n  */\n\n  ga.hit = function (a, b, react, bounce, global, extra) {\n    var collision;\n\n    //Set the defaults\n    react = react || false;\n    bounce = bounce || false;\n    global = global || false;\n\n    //Check to make sure one of the arguments isn't an array\n    if (b instanceof Array || a instanceof Array) {\n\n      //If it is, check for a collision between a sprite and an array\n      spriteVsArray();\n    } else {\n\n      //If one of the arguments isn't an array, find out what type of\n      //collision check to run\n      collision = findCollisionType(a, b);\n      if (collision && extra) extra(collision);\n    }\n\n    //Return the result of the collision.\n    //It will be `undefined` if there's no collision and `true` if\n    //there is a collision. `rectangleCollision` sets `collsision` to\n    //\"top\", \"bottom\", \"left\" or \"right\" depeneding on which side the\n    //collision is occuring on\n    return collision;\n\n    function findCollisionType(a, b) {\n\n      //Are `a` and `b` both sprites?\n      //(We have to check again if this function was called from\n      //`spriteVsArray`)\n      var aIsASprite = a.parent !== undefined,\n        bIsASprite = b.parent !== undefined;\n\n      if (aIsASprite && bIsASprite) {\n\n        //Yes, but what kind of sprites?\n        if (a.diameter && b.diameter) {\n\n          //They're circles\n          return circleVsCircle(a, b);\n        }\n        else if (a.diameter && !b.diameter) {\n\n          //The first one is a circle and the second is a rectangle\n          return circleVsRectangle(a, b);\n        }\n        else {\n\n          //They're rectangles\n          return rectangleVsRectangle(a, b);\n        }\n      }\n\n      //They're not both sprites, so what are they?\n      //Is `a` not a sprite and does it have x and y properties?\n      else if (bIsASprite && !(a.x === undefined) && !(a.y === undefined)) {\n\n        //Yes, so this is a point vs. sprite collision test\n        return ga.hitTestPoint(a, b);\n      }\n      else {\n        //The user is trying to test some incompatible objects\n        throw new Error(\"I'm sorry, \" + a + \" and \" + b + \" cannot be use together in a collision test.\");\n      }\n    }\n\n    function spriteVsArray() {\n\n      //If `a` happens to be the array, flip it around so that it becomes `b`\n      if (a instanceof Array) {\n        var temp = a;\n        b = a;\n        a = temp;\n      }\n\n      //Loop through the array in reverse\n      for (var i = b.length - 1; i >= 0; i--) {\n        var sprite = b[i];\n        collision = findCollisionType(a, sprite);\n        if (collision && extra) extra(collision, sprite);\n      }\n    }\n\n    function circleVsCircle(a, b) {\n\n      //If the circles shouldn't react to the collision,\n      //just test to see if they're touching\n      if (!react) {\n        return ga.hitTestCircle(a, b, global);\n      }\n\n      //Yes, the circles should react to the collision\n      else {\n\n        //Are they both moving?\n        if (a.vx + a.vy !== 0 && b.vx + b.vy !== 0) {\n\n          //Yes, they are both moving\n          //(moving circle collisions always bounce apart so there's\n          //no need for the third, `bounce`, argument)\n          return ga.movingCircleCollision(a, b, global);\n        }\n        else {\n\n          //No, they're not both moving\n          return ga.circleCollision(a, b, bounce, global);\n        }\n      }\n    }\n\n    function rectangleVsRectangle(a, b) {\n\n      //If the rectangles shouldn't react to the collision, just\n      //test to see if they're touching\n      if (!react) {\n        return ga.hitTestRectangle(a, b, global);\n      }\n      //Yes\n      else {\n\n        //Should they bounce apart?\n        //Yes\n        if (bounce) {\n          return ga.rectangleCollision(a, b, true, global);\n        }\n        //No\n        else {\n          return ga.rectangleCollision(a, b, false, global);\n        }\n      }\n    }\n\n    function circleVsRectangle(a, b) {\n\n      //If the rectangles shouldn't react to the collision, just\n      //test to see if they're touching\n      if (!react) {\n        return ga.hitTestCircleRectangle(a, b, global);\n      }\n      else {\n        return ga.circleRectangleCollision(a, b, bounce, global);\n      }\n    }\n  };\n\n  //### 2D Tile based collision utilities\n\n  //#### getIndex\n  //The `getIndex` helper method\n  //converts a sprite's x and y position to an array index number.\n  //It returns a single index value that tells you the map array\n  //index number that the sprite is in\n  ga.getIndex = function (x, y, tilewidth, tileheight, mapWidthInTiles) {\n    var index = {};\n\n    //Convert pixel coordinates to map index coordinates\n    index.x = Math.floor(x / tilewidth);\n    index.y = Math.floor(y / tileheight);\n\n    //Return the index number\n    return index.x + (index.y * mapWidthInTiles);\n  };\n\n  /*\n  #### getTile\n  The `getTile` helper method\n  converts a tile's index number into x/y screen\n  coordinates, and capture's the tile's grid index (`gid`) number.\n  It returns an object with `x`, `y`, `centerX`, `centerY`, `width`, `height`, `halfWidth`\n  `halffHeight` and `gid` properties. (The `gid` number is the value that the tile has in the\n  mapArray) This lets you use the returned object\n  with the 2d geometric collision functions like `hitTestRectangle`\n  or `rectangleCollision`\n\n  The `world` object requires these properties:\n  `x`, `y`, `tilewidth`, `tileheight` and `widthInTiles`\n  */\n  ga.getTile = function (index, mapArray, world) {\n    var tile = {}\n    tile.gid = mapArray[index];\n    tile.width = world.tilewidth;\n    tile.height = world.tileheight;\n    tile.halfWidth = world.tilewidth / 2;\n    tile.halfHeight = world.tileheight / 2;\n    tile.x = ((index % world.widthInTiles) * world.tilewidth) + world.x;\n    tile.y = ((Math.floor(index / world.widthInTiles)) * world.tileheight) + world.y;\n    tile.gx = tile.x;\n    tile.gy = tile.y;\n    tile.centerX = tile.x + world.tilewidth / 2;\n    tile.centery = tile.y + world.tileheight / 2;\n\n    //Return the tile object\n    return tile;\n  };\n\n  /*\n  #### surroundingCells\n  The `surroundingCells` helper method returns an array containing 9\n  index numbers of map array cells around any given index number.\n  Use it for an efficient broadphase/narrowphase collision test.\n  The 2 arguments are the index number that represents the center cell,\n  and the width of the map array.\n  */\n\n  ga.surroundingCells = function (index, widthInTiles) {\n    return [\n      index - widthInTiles - 1,\n      index - widthInTiles,\n      index - widthInTiles + 1,\n      index - 1,\n      index,\n      index + 1,\n      index + widthInTiles - 1,\n      index + widthInTiles,\n      index + widthInTiles + 1,\n    ];\n  };\n\n  //#### getPoints\n  /*\n  The `getPoints` method takes a sprite and returns\n  an object that tells you what all its corner points are.\n  If the sprite has a `collisionArea` property that defines a\n  smaller rectangular area inside the sprite, that collision\n  area will be used istead of the sprite's dimensions. Here's\n  How you could define a `collsionArea` on a sprite:\n\n      elf.collisionArea = {x: 22, y: 44, width: 20, height: 20};\n\n  */\n\n  ga.getPoints = function (s) {\n    var ca = s.collisionArea;\n    if (ca !== undefined) {\n      return {\n        topLeft: { x: s.x + ca.x, y: s.y + ca.y },\n        topRight: { x: s.x + ca.x + ca.width, y: s.y + ca.y },\n        bottomLeft: { x: s.x + ca.x, y: s.y + ca.y + ca.height },\n        bottomRight: { x: s.x + ca.x + ca.width, y: s.y + ca.y + ca.height }\n      };\n    } else {\n      return {\n        topLeft: { x: s.x, y: s.y },\n        topRight: { x: s.x + s.width - 1, y: s.y },\n        bottomLeft: { x: s.x, y: s.y + s.height - 1 },\n        bottomRight: { x: s.x + s.width - 1, y: s.y + s.height - 1 }\n      };\n    }\n  };\n\n  //### hitTestTile\n  /*\n  `hitTestTile` checks for a\n  collision between a sprite and a tile in any map array that you\n  specify. It returns a `collision` object.\n  `collision.hit` is a Boolean that tells you if a sprite is colliding\n  with the tile that you're checking. `collision.index` tells you the\n  map array's index number of the colliding sprite. You can check for\n  a collision with the tile against \"every\" corner point on the\n  sprite, \"some\" corner points, or the sprite's \"center\" point.\n  `hitTestTile` arguments:\n  sprite, array, collisionTileGridIdNumber, worldObject, spritesPointsToCheck\n  The `world` object (the 4th argument) has to have these properties:\n  `tileheight`, `tilewidth`, `widthInTiles`.\n  */\n\n  ga.hitTestTile = function (sprite, mapArray, gidToCheck, world, pointsToCheck) {\n\n    //Assign \"some\" as the default value for `pointsToCheck`\n    pointsToCheck = pointsToCheck || \"some\";\n\n    //The collision object that will be returned by this function\n    var collision = {};\n\n    //Which points do you want to check?\n    //\"every\", \"some\" or \"center\"?\n    switch (pointsToCheck) {\n      case \"center\":\n        //`hit` will be true only if the center point is touching\n        var point = { center: { x: sprite.centerX, y: sprite.centerY } };\n        sprite.collisionPoints = point;\n        collision.hit = Object.keys(sprite.collisionPoints).some(checkPoints);\n        break;\n      case \"every\":\n        //`hit` will be true if every point is touching\n        sprite.collisionPoints = ga.getPoints(sprite);\n        collision.hit = Object.keys(sprite.collisionPoints).every(checkPoints);\n        break;\n      case \"some\":\n        //`hit` will be true only if some points are touching\n        sprite.collisionPoints = ga.getPoints(sprite);\n        collision.hit = Object.keys(sprite.collisionPoints).some(checkPoints);\n        break;\n    }\n\n    //Loop through the sprite's corner points to find out if they are inside\n    //an array cell that you're interested in. Return `true` if they are\n\n    function checkPoints(key) {\n\n      //Get a reference to the current point to check.\n      //(`topLeft`, `topRight`, `bottomLeft` or `bottomRight` )\n      var point = sprite.collisionPoints[key];\n\n      //Find the point's index number in the map array\n      collision.index = ga.getIndex(\n        point.x, point.y,\n        world.tilewidth, world.tileheight, world.widthInTiles\n      );\n\n      //Find out what the gid value is in the map position\n      //that the point is currently over\n      collision.gid = mapArray[collision.index];\n\n      //If it matches the value of the gid that we're interested, in\n      //then there's been a collision\n      if (collision.gid === gidToCheck) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    //Return the collision object.\n    //`collision.hit` will be true if a collision is detected.\n    //`collision.index` tells you the map array index number where the\n    //collision occured\n    return collision;\n  };\n\n  //### updateMap\n  /*\n  `updateMap` takes a map array and adds a sprite's grid index number (`gid`) to it. \n  It finds the sprite's new index position, and retuns the new map array.\n  You can use it to do very efficient collision detection in tile based game worlds.\n  `updateMap` arguments:\n  array, singleSpriteOrArrayOfSprites, worldObject\n  The `world` object (the 4th argument) has to have these properties:\n  `tileheight`, `tilewidth`, `widthInTiles`.\n  The sprite objects have to have have these properties:\n  `centerX`, `centerY`, `index`, `gid` (The number in the array that represpents the sprite)\n  Here's an example of how you could use `updateMap` in your game code like this:\n  \n      blockLayer.data = g.updateMap(blockLayer.data, blockLayer.children, world);\n\n  The `blockLayer.data` array would now contain the new index position numbers of all the \n  child sprites on that layer.\n  */\n\n  ga.updateMap = function (mapArray, spritesToUpdate, world) {\n\n    //First create a map a new array filled with zeros.\n    //The new map array will be exactly the same size as the original\n    var newMapArray = mapArray.map(function (gid) {\n      gid = 0;\n      return gid;\n    });\n\n    //Is `spriteToUpdate` an array of sprites?\n    if (spritesToUpdate instanceof Array) {\n\n      //Get the index number of each sprite in the `spritesToUpdate` array\n      //and add the sprite's `gid` to the matching index on the map\n      spritesToUpdate.forEach(function (sprite) {\n\n        //Find the new index number\n        sprite.index = ga.getIndex(\n          sprite.centerX, sprite.centerY,\n          world.tilewidth, world.tileheight, world.widthInTiles\n        );\n\n        //Add the sprite's `gid` number to the correct index on the map\n        newMapArray[sprite.index] = sprite.gid;\n      });\n    }\n\n    //Is `spritesToUpdate` just a single sprite?\n    else {\n      var sprite = spritesToUpdate;\n      //Find the new index number\n      sprite.index = ga.getIndex(\n        sprite.centerX, sprite.centerY,\n        world.tilewidth, world.tileheight, world.widthInTiles\n      );\n\n      //Add the sprite's `gid` number to the correct index on the map\n      newMapArray[sprite.index] = sprite.gid;\n    }\n\n    //Return the new map array to replace the previous one\n    return newMapArray;\n  }\n\n  /*\n  Chapter 4: Sprite controllers\n  -----------------------------\n  */\n\n  //### fourKeyController\n\n  ga.fourKeyController = function (s, speed, up, right, down, left) {\n\n    //Create a `direction` property on the sprite\n    s.direction = \"\";\n\n    //Create some keyboard objects\n    leftArrow = ga.keyboard(left);\n    upArrow = ga.keyboard(up);\n    rightArrow = ga.keyboard(right);\n    downArrow = ga.keyboard(down);\n\n    //Assign key `press` and release methods\n    leftArrow.press = function () {\n      s.vx = -speed;\n      s.vy = 0;\n      s.direction = \"left\";\n    };\n    leftArrow.release = function () {\n      if (!rightArrow.isDown && s.vy === 0) {\n        s.vx = 0;\n      }\n    };\n    upArrow.press = function () {\n      s.vy = -speed;\n      s.vx = 0;\n      s.direction = \"up\";\n    };\n    upArrow.release = function () {\n      if (!downArrow.isDown && s.vx === 0) {\n        s.vy = 0;\n      }\n    };\n    rightArrow.press = function () {\n      s.vx = speed;\n      s.vy = 0;\n      s.direction = \"right\";\n    };\n    rightArrow.release = function () {\n      if (!leftArrow.isDown && s.vy === 0) {\n        s.vx = 0;\n      }\n    };\n    downArrow.press = function () {\n      s.vy = speed;\n      s.vx = 0;\n      s.direction = \"down\";\n    };\n    downArrow.release = function () {\n      if (!upArrow.isDown && s.vx === 0) {\n        s.vy = 0;\n      }\n    };\n  };\n\n  /*\n  Chapter 6: Tiled editor importers\n  ---------------------------------\n  Ga lets you import JSON files created by the popular Tiled Editor game map and level editor.\n\n  www.mapeditor.org\n\n  Two functions called `makeTiledWorld` and `makeIsoTiledWorld` (for isometric maps, coming soon!) use this data to\n  automatically build your game world for you.\n\n  To prepare your Tiled Editor game world for use in Ga, give any significant thing a\n  `name` property. Anything with a `name` property in Tiled Editor can\n  be accessed in your code by its string name. Tiled Editor layers have a\n  `name` property by default, and you can assign custom `name`\n  properties to tiles and objects. Not everything needs a `name` property, just\n  things that you want to specifically access in the world after its created.\n  */\n\n  /*\n  ### makeTiledWorld\n  */\n\n  ga.makeTiledWorld = function (tiledMap, tileset) {\n\n    //Create a group called `world` to contain all the layers, sprites\n    //and objects from the `tiledMap`. The `world` object is going to be\n    //returned to the main game program\n    tiledMap = ga.json(tiledMap);\n    var world = ga.group();\n    world.tileheight = tiledMap.tileheight;\n    world.tilewidth = tiledMap.tilewidth;\n\n    //Calculate the `width` and `height` of the world, in pixels\n    world.width = tiledMap.width * tiledMap.tilewidth;\n    world.height = tiledMap.height * tiledMap.tileheight;\n\n    //Get a reference to the world's height and width in\n    //tiles, in case you need to know this later (you will!)\n    world.widthInTiles = tiledMap.width;\n    world.heightInTiles = tiledMap.height;\n\n    //Create an `objects` array to store references to any\n    //named objects in the map. Named objects all have\n    //a `name` property that was assigned in Tiled Editor\n    world.objects = [];\n\n    //The optional spacing (padding) around each tile\n    //This is to account for spacing around tiles\n    //that's commonly used with texture atlas tilesets. Set the\n    //`spacing` property when you create a new map in Tiled Editor\n    var spacing = tiledMap.tilesets[0].spacing;\n\n    //Figure out how many columns there are on the tileset.\n    //This is the width of the image, divided by the width\n    //of each tile, plus any optional spacing thats around each tile\n    var numberOfTilesetColumns =\n      Math.floor(\n        tiledMap.tilesets[0].imagewidth\n        / (tiledMap.tilewidth + spacing)\n      );\n\n    //Loop through all the map layers\n    tiledMap.layers.forEach(function (tiledLayer) {\n\n      //Make a group for this layer and copy\n      //all of the layer properties onto it.\n      var layerGroup = ga.group();\n\n      Object.keys(tiledLayer).forEach(function (key) {\n        //Add all the layer's properties to the group, except the\n        //width and height (because the group will work those our for\n        //itself based on its content).\n        if (key !== \"width\" && key !== \"height\") {\n          layerGroup[key] = tiledLayer[key];\n        }\n      });\n\n      //Set the width and height of the layer to\n      //the `world`'s width and height\n      //layerGroup.width = world.width;\n      //layerGroup.height = world.height;\n\n      //Translate `opacity` to `alpha`\n      layerGroup.alpha = tiledLayer.opacity;\n\n      //Add the group to the `world`\n      world.addChild(layerGroup);\n\n      //Push the group into the world's `objects` array\n      //So you can access it later\n      world.objects.push(layerGroup);\n\n      //Is this current layer a `tilelayer`?\n      if (tiledLayer.type === \"tilelayer\") {\n\n        //Loop through the `data` array of this layer\n        tiledLayer.data.forEach(function (gid, index) {\n          var tileSprite, texture, mapX, mapY, tilesetX, tilesetY,\n            mapColumn, mapRow, tilesetColumn, tilesetRow;\n          //If the grid id number (`gid`) isn't zero, create a sprite\n          if (gid !== 0) {\n            //Figure out the map column and row number that we're on, and then\n            //calculate the grid cell's x and y pixel position.\n            mapColumn = index % world.widthInTiles;\n            mapRow = Math.floor(index / world.widthInTiles);\n            mapX = mapColumn * world.tilewidth;\n            mapY = mapRow * world.tileheight;\n\n            //Figure out the column and row number that the tileset\n            //image is on, and then use those values to calculate\n            //the x and y pixel position of the image on the tileset\n            tilesetColumn = ((gid - 1) % numberOfTilesetColumns);\n            tilesetRow = Math.floor((gid - 1) / numberOfTilesetColumns);\n            tilesetX = tilesetColumn * world.tilewidth;\n            tilesetY = tilesetRow * world.tileheight;\n\n            //Compensate for any optional spacing (padding) around the tiles if\n            //there is any. This bit of code accumlates the spacing offsets from the\n            //left side of the tileset and adds them to the current tile's position\n            if (spacing > 0) {\n              tilesetX\n                += spacing\n                + (spacing * ((gid - 1) % numberOfTilesetColumns));\n              tilesetY\n                += spacing\n                + (spacing * Math.floor((gid - 1) / numberOfTilesetColumns));\n            }\n\n            //Use the above values to create the sprite's image from\n            //the tileset image\n            texture = ga.frame(\n              tileset, tilesetX, tilesetY,\n              world.tilewidth, world.tileheight\n            );\n\n            //I've dedcided that any tiles that have a `name` property are important\n            //and should be accessible in the `world.objects` array.\n\n            var tileproperties = tiledMap.tilesets[0].tileproperties,\n              key = String(gid - 1);\n\n            //If the JSON `tileproperties` object has a sub-object that\n            //matches the current tile, and that sub-object has a `name` property,\n            //then create a sprite and assign the tile properties onto\n            //the sprite\n            if (tileproperties[key] && tileproperties[key].name) {\n\n              //Make a sprite\n              tileSprite = ga.sprite(texture);\n\n              //Copy all of the tile's properties onto the sprite\n              //(This includes the `name` property)\n              Object.keys(tileproperties[key]).forEach(function (property) {\n\n                //console.log(tileproperties[key][property])\n                tileSprite[property] = tileproperties[key][property];\n              });\n\n              //Push the sprite into the world's `objects` array\n              //so that you can access it by `name` later\n              world.objects.push(tileSprite);\n            }\n\n            //If the tile doesn't have a `name` property, just use it to\n            //create an ordinary sprite (it will only need one texture)\n            else {\n              tileSprite = ga.sprite(texture);\n            }\n\n            //Position the sprite on the map\n            tileSprite.x = mapX;\n            tileSprite.y = mapY;\n\n            //Make a record of the sprite's index number in the array\n            //(We'll use this for collision detection later)\n            tileSprite.index = index;\n\n            //Make a record of the sprite's `gid` on the tileset.\n            //This will also be useful for collision detection later\n            tileSprite.gid = gid;\n\n            //Add the sprite to the current layer group\n            layerGroup.addChild(tileSprite);\n          }\n        });\n      } else \n      //Is this layer an `objectgroup`?\n      if (tiledLayer.type === \"objectgroup\") {\n        //Because this is an object layer, it doesn't contain any\n        //sprites, just data object. That means it won't be able to\n        //calucalte its own height and width. To help it out, give\n        //the `layerGroup` the same `width` and `height` as the `world`\n        layerGroup.width = world.width;\n        layerGroup.height = world.height;\n        tiledLayer.objects.forEach(function (object) {\n          //We're just going to capture the object's properties\n          //so that we can decide what to do with it later\n\n          //Get a reference to the layer group the object is in\n          object.group = layerGroup;\n          //Push the object into the world's `objects` array\n          world.objects.push(object);\n        });\n      } else \n      //Is this layer an `imagelayer`?\n      if (tiledLayer.type === \"imagelayer\") {        \n        let img = ga.sprite(tiledLayer.image);\n        img.width = layerGroup.width = world.width;\n        img.height = layerGroup.height = world.height;\n        layerGroup.addChild(img);\n      }\n    });\n\n    //Search functions\n    //`world.getObject` and `world.getObjects`  search for and return\n    //any sprites or objects in the `world.objects` array.\n    //Any object that has a `name` propery in\n    //Tiled Editor will show up in a search.\n    //`getObject` gives you a single object, `getObjects` gives you an array\n    //of objects.\n    //`getObject` returns the actual search function, so you\n    //can use the following format to directly access a single object:\n    //sprite.x = world.getObject(\"anySprite\").x;\n    //sprite.y = world.getObject(\"anySprite\").y;\n\n    world.getObject = function (objectName) {\n      this.searchForObject = function () {\n        var foundObject;\n        world.objects.some(function (object) {\n          if (object.name && object.name === objectName) {\n            foundObject = object;\n            return true;\n          }\n        });\n        if (foundObject) {\n          return foundObject;\n        } else {\n          console.log(\"There is no object with the property name: \" + objectName);\n        }\n      };\n\n      //Return the search function\n      return this.searchForObject();\n    };\n\n    world.getObjects = function (namesOfObjects) {\n      var objectNames = Array.prototype.slice.call(arguments);\n      var foundObjects = [];\n      world.objects.forEach(function (object) {\n        if (object.name && objectNames.indexOf(object.name) !== -1) {\n          foundObjects.push(object);\n        }\n      });\n      if (foundObjects.length > 0) {\n        return foundObjects;\n      } else {\n        console.log(\"I could not find those objects\");\n      }\n      return foundObjects;\n    };\n\n    //That's it, we're done!\n    //Finally, return the `world` object back to the game program\n    return world;\n  };\n\n  /*\n  Chapter 7: The fullscreen module\n  ---------------------------------\n  \n  Ga has a very simple way of running a game fullscreen:\n\n      g.enableFullscreen();\n\n  Add that to your game code just after the `start` method. As soon as the user\n  clicks or touches the game canvas, the game will enter fullscreen mode. The\n  game will be aligned and centered in the screen. \n  \n  To exit fullscreen mode, the user can press `esc` on the keyboard. Or, you can \n  define your own custom exit keys by providing ascii key code numbers as \n  `enableFullScreen`'s arguments, like this:\n\n      g.enableFullscreen(88, 120);\n\n  In this case pressing lowercase `x` (88) or uppercase `X` (120) will exit fullscreen \n  mode. If you choose to use fullscreen mode, make sure you inform your users\n  of the keys they need to press to exit it! \n  \n  Or, preferably, don't use fullscreen mode at all. Many users will panic when your\n  game takes over their entire screen, and may not intuitively understand how to \n  exit fullscreen mode. So, instead, consider using Ga's more user-friendly\n  `scaleToWindow` method (listed in the code above.) `scaleToWindow` scales the game\n  to the maximum browser window size and center aligns it for the best fit, without\n  removing the browser's UI.\n\n  An important note about fullscreen mode: The WHATWG spec only allows fullscreen mode\n  to be activated if a user interacts with an HTML element (https://fullscreen.spec.whatwg.org).\n  That means you can't use any of Ga's button `press` or `release` actions to \n  launch fullscreen mode. That's because buttons are canvas based code objects, not HTML\n  elements. You'll see in the code below that fullscreen mode is launched using an \n  event listener attached directly to Ga's canvas.\n\n  (A Fullscreen API polyfill exists at the head of the `ga.js` file)\n\n  */\n\n  //`fullscreenScale` is used to track the size of the scaled canvas\n  //Ga's update loop need to know this so that it can dynmaically\n  //adjust `ga.scale` and `ga.pointer.scale` depending on whether\n  //fullscreen mode is active. \n  ga.fullscreenScale = 1;\n\n  //`requestFullscreen` is used by `enableFullscreen` to launch\n  //fullscreen mode.\n  ga.requestFullScreen = function () {\n    if (!document.fullscreenEnabled) {\n      ga.canvas.requestFullscreen();\n    }\n  };\n\n  //`exitFullscreen` is used by `enableFullscreen` to exit\n  //fullscreen mode.\n  ga.exitFullScreen = function () {\n    if (document.fullscreenEnabled) {\n      document.exitFullscreen();\n    }\n  };\n\n  //`alignFullscreen` is called by `enableFullscreen` to center and\n  //align the canvas vertically or horizontally inside the users\n  //screen. It also sets `ga.fullscreenScale` that Ga's `update` loop\n  //uses to changed the values of `ga.scale` and `ga.pointer.scale`\n  //when fullscreen mode is entered or exited.\n  ga.alignFullscreen = function () {\n    var scaleX, scaleY;\n\n    //Scale the canvas to the correct size.\n    //Figure out the scale amount on each axis.\n    scaleX = screen.width / ga.canvas.width;\n    scaleY = screen.height / ga.canvas.height;\n\n    //Set the scale based on whichever value is less: `scaleX` or `scaleY`.\n    ga.fullscreenScale = Math.min(scaleX, scaleY);\n\n    //To center the canvas we need to inject some CSS\n    //and into the HTML document's `<style>` tag. Some\n    //browsers require an existing `<style>` tag to do this, so\n    //if no `<style>` tag already exists, let's create one and\n    //append it to the `<body>:\n    var styleSheets = document.styleSheets;\n    if (styleSheets.length === 0) {\n      var divNode = document.createElement(\"div\");\n      divNode.innerHTML = \"<style></style>\";\n      document.body.appendChild(divNode);\n    }\n\n    //Unfortunately we also need to do some browser detection\n    //to inject the full screen CSS with the correct vendor \n    //prefix. So, let's find out what the `userAgent` is.\n    //`ua` will be an array containing lower-case browser names.\n    var ua = navigator.userAgent.toLowerCase();\n\n    //Now Decide whether to center the canvas vertically or horizontally.\n    //Wide canvases should be centered vertically, and \n    //square or tall canvases should be centered horizontally.\n\n    if (ga.canvas.width > ga.canvas.height) {\n\n      //Center vertically.\n      //Add CSS to the stylesheet to center the canvas vertically.\n      //You need a version for each browser vendor, plus a generic\n      //version\n      //(Unfortunately the CSS string cannot include line breaks, so\n      //it all has to be on one long line.)\n      if (ua.indexOf(\"safari\") !== -1 || ua.indexOf(\"chrome\") !== -1) {\n        document.styleSheets[0].insertRule(\"canvas:-webkit-full-screen {position: fixed; width: 100%; height: auto; top: 0; right: 0; bottom: 0; left: 0; margin: auto; object-fit: contain}\", 0);\n      }\n      else if (ua.indexOf(\"firefox\") !== -1) {\n        document.styleSheets[0].insertRule(\"canvas:-moz-full-screen {position: fixed; width: 100%; height: auto; top: 0; right: 0; bottom: 0; left: 0; margin: auto; object-fit: contain;}\", 0);\n      }\n      else if (ua.indexOf(\"opera\") !== -1) {\n        document.styleSheets[0].insertRule(\"canvas:-o-full-screen {position: fixed; width: 100%; height: auto; top: 0; right: 0; bottom: 0; left: 0; margin: auto; object-fit: contain;}\", 0);\n      }\n      else if (ua.indexOf(\"explorer\") !== -1) {\n        document.styleSheets[0].insertRule(\"canvas:-ms-full-screen {position: fixed; width: 100%; height: auto; top: 0; right: 0; bottom: 0; left: 0; margin: auto; object-fit: contain;}\", 0);\n      }\n      else {\n        document.styleSheets[0].insertRule(\"canvas:fullscreen {position: fixed; width: 100%; height: auto; top: 0; right: 0; bottom: 0; left: 0; margin: auto; object-fit: contain;}\", 0);\n      }\n    } else {\n\n      //Center horizontally.\n      if (ua.indexOf(\"safari\") !== -1 || ua.indexOf(\"chrome\") !== -1) {\n        document.styleSheets[0].insertRule(\"canvas:-webkit-full-screen {height: 100%; margin: 0 auto; object-fit: contain;}\", 0);\n      }\n      else if (ua.indexOf(\"firefox\") !== -1) {\n        document.styleSheets[0].insertRule(\"canvas:-moz-full-screen {height: 100%; margin: 0 auto; object-fit: contain;}\", 0);\n      }\n      else if (ua.indexOf(\"opera\") !== -1) {\n        document.styleSheets[0].insertRule(\"canvas:-o-full-screen {height: 100%; margin: 0 auto; object-fit: contain;}\", 0);\n      }\n      else if (ua.indexOf(\"msie\") !== -1) {\n        document.styleSheets[0].insertRule(\"canvas:-ms-full-screen {height: 100%; margin: 0 auto; object-fit: contain;}\", 0);\n      }\n      else {\n        document.styleSheets[0].insertRule(\"canvas:fullscreen {height: 100%; margin: 0 auto; object-fit: contain;}\", 0);\n      }\n    }\n  };\n\n  //### enableFullscreen\n  /*\n  Use `enterFullscreen` to make the browser display the game full screen.\n  It automatically centers the game canvas for the best fit. Optionally supply any number of ascii\n  keycodes as arguments to represent the keyboard keys that should exit fullscreen mode.\n  */\n  ga.enableFullscreen = function (exitKeyCodes) {\n\n    //Get an array of the optional exit key codes.\n    if (exitKeyCodes) exitKeyCodes = Array.prototype.slice.call(arguments);\n\n    //Center and align the fullscreen element.\n    ga.alignFullscreen();\n\n    //Add mouse and touch listeners to the canvas to enable\n    //fullscreen mode.\n    ga.canvas.addEventListener(\"mouseup\", ga.requestFullScreen, false);\n    ga.canvas.addEventListener(\"touchend\", ga.requestFullScreen, false);\n\n    if (exitKeyCodes) {\n      exitKeyCodes.forEach(function (keyCode) {\n        window.addEventListener(\n          \"keyup\",\n          function (event) {\n            if (event.keyCode === keyCode) {\n              ga.exitFullScreen();\n            }\n            event.preventDefault();\n          },\n          false\n        );\n      });\n    }\n  }\n\n  ga.launchFullscreen = function (sprite) {\n    if (ga.hitTestPoint(ga.pointer.position, sprite)) ga.enableFullscreen();\n  }\n\n  //This next function checks to see if the game is in \n  //full screen mode. If it is, the game's scale is set\n  //to `fullscreen.scale`. If not, and the canvas hasn't already\n  //been scaled, the scale reverts back to 1.   \n  ga.scaleFullscreen = function () {\n    if (document.fullscreenEnabled) {\n      ga.scale = ga.fullscreenScale;\n      ga.pointer.scale = ga.fullscreenScale;\n    } else {\n      if (!ga.canvas.scaled) {\n        ga.scale = 1;\n        ga.pointer.scale = 1;\n      }\n    }\n  }\n\n  //Push `scaleFullscreen` into the `updateFunctions` array so that\n  //it will be updated by Ga's `update` function on each frame of the\n  //game loop.\n  ga.updateFunctions.push(ga.scaleFullscreen);\n\n  /*\n  Chapter 8: Sound\n  ----------------\n  */\n\n  //Create an audio context.\n  ga.actx = new AudioContext();\n\n  /*\n\n  ###makeSound\n\n  `makeSound` is the function you want to use to load and play sound files.\n  It creates and returns and WebAudio sound object with lots of useful methods you can\n  use to control the sound. \n  You can use it to load a sound like this:\n\n      var anySound = makeSound(\"sounds/anySound.mp3\", loadHandler);\n\n  The code above will load the sound and then call the `loadHandler`\n  when the sound has finished loading. \n  (However, it's more convenient to load the sound file by pre-loading it in Ga's\n  assets array, so I don't recommend loading sounds\n  like this unless you need more low-level control.)\n\n  After the sound has been loaded you can access and use it like this:\n\n      function loadHandler() {\n        anySound.loop = true;\n        anySound.pan = 0.8;\n        anySound.volume = 0.5;\n        anySound.play();\n        anySound.pause();\n        anySound.playFrom(second);\n        anySound.restart();\n        anySound.setReverb(2, 2, false);\n        anySound.setEcho(0.2, 0.2, 0);\n        anySound.playbackRate = 0.5;\n        anySound.fadeOut(timeInSeconds);\n        anySound.fadeIn(timeInSeconds);\n        anySound.fade(targetVolume, timeInSeconds);\n      }\n  */\n\n  ga.makeSound = function (source, loadHandler) {\n\n    //The sound object that this function returns.\n    var o = {};\n\n    //The audio context\n    var actx = ga.actx\n\n    //Set the default properties.\n    o.volumeNode = ga.actx.createGain();\n\n    //Create the pan node using the effcient `createStereoPanner`\n    //method, if it's available.\n    if (!actx.createStereoPanner) {\n      o.panNode = actx.createPanner();\n    } else {\n      o.panNode = actx.createStereoPanner();\n    }\n    o.delayNode = actx.createDelay();\n    o.feedbackNode = actx.createGain();\n    o.filterNode = actx.createBiquadFilter();\n    o.convolverNode = actx.createConvolver();\n    o.soundNode = null;\n    o.buffer = null;\n    o.source = null;\n    o.loop = false;\n    o.playing = false;\n\n    //The function that should run when the sound is loaded.\n    o.loadHandler = undefined;\n\n    //Values for the `pan` and `volume` getters/setters.\n    o.panValue = 0;\n    o.volumeValue = 1;\n\n    //Values to help track and set the start and pause times.\n    o.startTime = 0;\n    o.startOffset = 0;\n\n    //Set the playback rate.\n    o.playbackRate = 1;\n\n    //Echo properties.\n    o.echo = false;\n    o.delayValue = 0.3;\n    o.feebackValue = 0.3;\n    o.filterValue = 0;\n\n    //Reverb properties\n    o.reverb = false;\n    o.reverbImpulse = null;\n\n    //The sound object's methods.\n    o.play = function () {\n\n      //Set the start time (it will be `0` when the sound\n      //first starts.\n      o.startTime = actx.currentTime;\n\n      //Create a sound node.\n      o.soundNode = actx.createBufferSource();\n\n      //Set the sound node's buffer property to the loaded sound.\n      o.soundNode.buffer = o.buffer;\n\n      //Set the playback rate\n      o.soundNode.playbackRate.value = this.playbackRate;\n\n      //Connect the sound to the pan, connect the pan to the\n      //volume, and connect the volume to the destination.\n      o.soundNode.connect(o.volumeNode);\n\n      //If there's no reverb, bypass the convolverNode\n      if (o.reverb === false) {\n        o.volumeNode.connect(o.panNode);\n      }\n\n      //If there is reverb, connect the `convolverNode` and apply\n      //the impulse response\n      else {\n        o.volumeNode.connect(o.convolverNode);\n        o.convolverNode.connect(o.panNode);\n        o.convolverNode.buffer = o.reverbImpulse;\n      }\n\n      //Connect the `panNode` to the destination to complete the chain.\n      o.panNode.connect(actx.destination);\n\n      //Add optional echo.\n      if (o.echo) {\n\n        //Set the values.\n        o.feedbackNode.gain.value = o.feebackValue;\n        o.delayNode.delayTime.value = o.delayValue;\n        o.filterNode.frequency.value = o.filterValue;\n\n        //Create the delay loop, with optional filtering.\n        o.delayNode.connect(o.feedbackNode);\n        if (o.filterValue > 0) {\n          o.feedbackNode.connect(o.filterNode);\n          o.filterNode.connect(o.delayNode);\n        } else {\n          o.feedbackNode.connect(o.delayNode);\n        }\n\n        //Capture the sound from the main node chain, send it to the\n        //delay loop, and send the final echo effect to the `panNode` which\n        //will then route it to the destination.\n        o.volumeNode.connect(o.delayNode);\n        o.delayNode.connect(o.panNode);\n      }\n\n      //Will the sound loop? This can be `true` or `false`.\n      o.soundNode.loop = o.loop;\n\n      //Finally, use the `start` method to play the sound.\n      //The start time will either be `0`,\n      //or a later time if the sound was paused.\n      o.soundNode.start(\n        0, o.startOffset % o.buffer.duration\n      );\n\n      //Set `playing` to `true` to help control the\n      //`pause` and `restart` methods.\n      o.playing = true;\n    };\n\n    o.pause = function () {\n      //Pause the sound if it's playing, and calculate the\n      //`startOffset` to save the current position.\n      if (o.playing) {\n        o.soundNode.stop(0);\n        o.startOffset += actx.currentTime - o.startTime;\n        o.playing = false;\n      }\n    };\n\n    o.restart = function () {\n      //Stop the sound if it's playing, reset the start and offset times,\n      //then call the `play` method again.\n      if (o.playing) {\n        o.soundNode.stop(0);\n      }\n      o.startOffset = 0;\n      o.play();\n    };\n\n    o.playFrom = function (value) {\n      if (o.playing) {\n        o.soundNode.stop(0);\n      }\n      o.startOffset = value;\n      o.play();\n    };\n\n    o.setEcho = function (delayValue, feedbackValue, filterValue) {\n      if (delayValue === undefined) delayValue = 0.3;\n      if (feedbackValue === undefined) feedbackValue = 0.3;\n      if (filterValue === undefined) filterValue = 0;\n      o.delayValue = delayValue;\n      o.feebackValue = feedbackValue;\n      o.filterValue = filterValue;\n      o.echo = true;\n    };\n\n    o.setReverb = function (duration, decay, reverse) {\n      if (duration === undefined) duration = 2;\n      if (decay === undefined) decay = 2;\n      if (reverse === undefined) reverse = false;\n      o.reverbImpulse = ga.impulseResponse(duration, decay, reverse, actx);\n      o.reverb = true;\n    };\n\n    //A general purpose `fade` method for fading sounds in or out.\n    //The first argument is the volume that the sound should\n    //fade to, and the second value is the duration, in seconds,\n    //that the fade should last.\n    o.fade = function (endValue, durationInSeconds) {\n      if (o.playing) {\n        o.volumeNode.gain.linearRampToValueAtTime(\n          o.volumeNode.gain.value, actx.currentTime\n        );\n        o.volumeNode.gain.linearRampToValueAtTime(\n          endValue, actx.currentTime + durationInSeconds\n        );\n      }\n    };\n\n    //Fade a sound in, from an intial volume level of zero.\n    o.fadeIn = function (durationInSeconds) {\n\n      //Set the volume to 0 so that you can fade\n      //in from silence\n      o.volumeNode.gain.value = 0;\n      o.fade(1, durationInSeconds);\n\n    };\n\n    //Fade a sound out, from its current volume level to zero.\n    o.fadeOut = function (durationInSeconds) {\n      o.fade(0, durationInSeconds);\n    };\n\n    //Volume and pan getters/setters.\n    Object.defineProperties(o, {\n      volume: {\n        get: function () {\n          return o.volumeValue;\n        },\n        set: function (value) {\n          o.volumeNode.gain.value = value;\n          o.volumeValue = value;\n        },\n        enumerable: true, configurable: true\n      },\n\n      //The pan node uses the high-effciency stereo panner, if it's\n      //available. But, because this is a new addition to the \n      //WebAudio spec, it might not be available on all browsers.\n      //So the code checks for this and uses the older 3D panner\n      //if 2D isn't available.\n      pan: {\n        get: function () {\n          if (!actx.createStereoPanner) {\n            return o.panValue;\n          } else {\n            return o.panNode.pan.value;\n          }\n        },\n        set: function (value) {\n          if (!actx.createStereoPanner) {\n            //Panner objects accept x, y and z coordinates for 3D\n            //sound. However, because we're only doing 2D left/right\n            //panning we're only interested in the x coordinate,\n            //the first one. However, for a natural effect, the z\n            //value also has to be set proportionately.\n            var x = value,\n              y = 0,\n              z = 1 - Math.abs(x);\n            o.panNode.setPosition(x, y, z);\n            o.panValue = value;\n          } else {\n            o.panNode.pan.value = value;\n          }\n        },\n        enumerable: true, configurable: true\n      }\n    });\n\n    //The `load` method. It will call the `loadHandler` passed\n    //that was passed as an argument when the sound has loaded.\n    o.load = function () {\n      var xhr = new XMLHttpRequest();\n\n      //Use xhr to load the sound file.\n      xhr.open(\"GET\", source, true);\n      xhr.responseType = \"arraybuffer\";\n      xhr.addEventListener(\"load\", function () {\n\n        //Decode the sound and store a reference to the buffer.\n        actx.decodeAudioData(\n          xhr.response,\n          function (buffer) {\n            o.buffer = buffer;\n            o.hasLoaded = true;\n\n            //This next bit is optional, but important.\n            //If you have a load manager in your game, call it here so that\n            //the sound is registered as having loaded.\n            if (loadHandler) {\n              loadHandler();\n            }\n          },\n\n          //Throw an error if the sound can't be decoded.\n          function (error) {\n            throw new Error(\"Audio could not be decoded: \" + error);\n          }\n        );\n      });\n\n      //Send the request to load the file.\n      xhr.send();\n    };\n\n    //Load the sound.\n    o.load();\n\n    //Return the sound object.\n    return o;\n  };\n\n  //### sound\n  //A convenience method that lets you access loaded sounds by their file names.\n  ga.sound = function (soundFileName) {\n    return ga.assets[soundFileName];\n  };\n\n  /*\n  ###soundEffect\n\n  The `soundEffect` function lets you generate your sounds and musical notes from scratch\n  (Reverb effect requires the `impulseResponse` function that you'll see further ahead in this file)\n\n  To create a custom sound effect, define all the parameters that characterize your sound. Here's how to\n  create a laser shooting sound:\n\n      soundEffect(\n        1046.5,           //frequency\n        0,                //attack\n        0.3,              //decay\n        \"sawtooth\",       //waveform\n        1,                //Volume\n        -0.8,             //pan\n        0,                //wait before playing\n        1200,             //pitch bend amount\n        false,            //reverse bend\n        0,                //random pitch range\n        25,               //dissonance\n        [0.2, 0.2, 2000], //echo: [delay, feedback, filter]\n        undefined         //reverb: [duration, decay, reverse?]\n      );\n\n  Experiment by changing these parameters to see what kinds of effects you can create, and build\n  your own library of custom sound effects for games.\n  */\n  ga.soundEffect = function (\n    frequencyValue,      //The sound's fequency pitch in Hertz\n    attack,              //The time, in seconds, to fade the sound in\n    decay,               //The time, in seconds, to fade the sound out\n    type,                //waveform type: \"sine\", \"triangle\", \"square\", \"sawtooth\"\n    volumeValue,         //The sound's maximum volume\n    panValue,            //The speaker pan. left: -1, middle: 0, right: 1\n    wait,                //The time, in seconds, to wait before playing the sound\n    pitchBendAmount,     //The number of Hz in which to bend the sound's pitch down\n    reverse,             //If `reverse` is true the pitch will bend up\n    randomValue,         //A range, in Hz, within which to randomize the pitch\n    dissonance,          //A value in Hz. It creates 2 dissonant frequencies above and below the target pitch\n    echo,                //An array: [delayTimeInSeconds, feedbackTimeInSeconds, filterValueInHz]\n    reverb               //An array: [durationInSeconds, decayRateInSeconds, reverse]\n  ) {\n\n    //Set the default values\n    if (frequencyValue === undefined) frequencyValue = 200;\n    if (attack === undefined) attack = 0;\n    if (decay === undefined) decay = 1;\n    if (type === undefined) type = \"sine\";\n    if (volumeValue === undefined) volumeValue = 1;\n    if (panValue === undefined) panValue = 0;\n    if (wait === undefined) wait = 0;\n    if (pitchBendAmount === undefined) pitchBendAmount = 0;\n    if (reverse === undefined) reverse = false;\n    if (randomValue === undefined) randomValue = 0;\n    if (dissonance === undefined) dissonance = 0;\n    if (echo === undefined) echo = undefined;\n    if (reverb === undefined) reverb = undefined;\n\n    //The audio context\n    var actx = ga.actx;\n\n    //Create an oscillator, gain and pan nodes, and connect them\n    //together to the destination\n    var oscillator, volume, pan;\n    oscillator = actx.createOscillator();\n    volume = actx.createGain();\n    if (!actx.createStereoPanner) {\n      pan = actx.createPanner();\n    } else {\n      pan = actx.createStereoPanner();\n    }\n    oscillator.connect(volume);\n    volume.connect(pan);\n    pan.connect(actx.destination);\n\n    //Set the supplied values\n    volume.gain.value = volumeValue;\n    if (!actx.createStereoPanner) {\n      pan.setPosition(panValue, 0, 1 - Math.abs(panValue));\n    } else {\n      pan.pan.value = panValue;\n    }\n    oscillator.type = type;\n\n    //Optionally randomize the pitch. If the `randomValue` is greater\n    //than zero, a random pitch is selected that's within the range\n    //specified by `frequencyValue`. The random pitch will be either\n    //above or below the target frequency.\n    var frequency;\n    var randomInt = function (min, max) {\n      return Math.floor(Math.random() * (max - min + 1)) + min\n    };\n    if (randomValue > 0) {\n      frequency = randomInt(\n        frequencyValue - randomValue / 2,\n        frequencyValue + randomValue / 2\n      );\n    } else {\n      frequency = frequencyValue;\n    }\n    oscillator.frequency.value = frequency;\n\n    //Apply effects\n    if (attack > 0) fadeIn(volume);\n    fadeOut(volume);\n    if (pitchBendAmount > 0) pitchBend(oscillator);\n    if (echo) addEcho(volume);\n    if (reverb) addReverb(volume);\n    if (dissonance > 0) addDissonance();\n\n    //Play the sound\n    play(oscillator);\n\n    //The helper functions:\n\n    function addReverb(volumeNode) {\n      var convolver = actx.createConvolver();\n      convolver.buffer = ga.impulseResponse(reverb[0], reverb[1], reverb[2], actx);\n      volumeNode.connect(convolver);\n      convolver.connect(pan);\n    }\n\n    function addEcho(volumeNode) {\n\n      //Create the nodes\n      var feedback = actx.createGain(),\n        delay = actx.createDelay(),\n        filter = actx.createBiquadFilter();\n\n      //Set their values (delay time, feedback time and filter frequency)\n      delay.delayTime.value = echo[0];\n      feedback.gain.value = echo[1];\n      if (echo[2]) filter.frequency.value = echo[2];\n\n      //Create the delay feedback loop, with\n      //optional filtering\n      delay.connect(feedback);\n      if (echo[2]) {\n        feedback.connect(filter);\n        filter.connect(delay);\n      } else {\n        feedback.connect(delay);\n      }\n\n      //Connect the delay loop to the oscillator's volume\n      //node, and then to the destination\n      volumeNode.connect(delay);\n\n      //Connect the delay loop to the main sound chain's\n      //pan node, so that the echo effect is directed to\n      //the correct speaker\n      delay.connect(pan);\n    }\n\n    //The `fadeIn` function\n    function fadeIn(volumeNode) {\n\n      //Set the volume to 0 so that you can fade\n      //in from silence\n      volumeNode.gain.value = 0;\n\n      volumeNode.gain.linearRampToValueAtTime(\n        0, actx.currentTime + wait\n      );\n      volumeNode.gain.linearRampToValueAtTime(\n        volumeValue, actx.currentTime + wait + attack\n      );\n    }\n\n    //The `fadeOut` function\n    function fadeOut(volumeNode) {\n      volumeNode.gain.linearRampToValueAtTime(\n        volumeValue, actx.currentTime + attack + wait\n      );\n      volumeNode.gain.linearRampToValueAtTime(\n        0, actx.currentTime + wait + attack + decay\n      );\n    }\n\n    //The `pitchBend` function\n    function pitchBend(oscillatorNode) {\n\n      //If `reverse` is true, make the note drop in frequency. Useful for\n      //shooting sounds\n\n      //Get the frequency of the current oscillator\n      var frequency = oscillatorNode.frequency.value;\n\n      //If `reverse` is true, make the sound drop in pitch\n      if (!reverse) {\n        oscillatorNode.frequency.linearRampToValueAtTime(\n          frequency,\n          actx.currentTime + wait\n        );\n        oscillatorNode.frequency.linearRampToValueAtTime(\n          frequency - pitchBendAmount,\n          actx.currentTime + wait + attack + decay\n        );\n      }\n\n      //If `reverse` is false, make the note rise in pitch. Useful for\n      //jumping sounds\n      else {\n        oscillatorNode.frequency.linearRampToValueAtTime(\n          frequency,\n          actx.currentTime + wait\n        );\n        oscillatorNode.frequency.linearRampToValueAtTime(\n          frequency + pitchBendAmount,\n          actx.currentTime + wait + attack + decay\n        );\n      }\n    }\n\n    //The `addDissonance` function\n    function addDissonance() {\n\n      //Create two more oscillators and gain nodes\n      var d1 = actx.createOscillator(),\n        d2 = actx.createOscillator(),\n        d1Volume = actx.createGain(),\n        d2Volume = actx.createGain();\n\n      //Set the volume to the `volumeValue`\n      d1Volume.gain.value = volumeValue;\n      d2Volume.gain.value = volumeValue;\n\n      //Connect the oscillators to the gain and destination nodes\n      d1.connect(d1Volume);\n      d1Volume.connect(actx.destination);\n      d2.connect(d2Volume);\n      d2Volume.connect(actx.destination);\n\n      //Set the waveform to \"sawtooth\" for a harsh effect\n      d1.type = \"sawtooth\";\n      d2.type = \"sawtooth\";\n\n      //Make the two oscillators play at frequencies above and\n      //below the main sound's frequency. Use whatever value was\n      //supplied by the `dissonance` argument\n      d1.frequency.value = frequency + dissonance;\n      d2.frequency.value = frequency - dissonance;\n\n      //Fade in/out, pitch bend and play the oscillators\n      //to match the main sound\n      if (attack > 0) {\n        fadeIn(d1Volume);\n        fadeIn(d2Volume);\n      }\n      if (decay > 0) {\n        fadeOut(d1Volume);\n        fadeOut(d2Volume);\n      }\n      if (pitchBendAmount > 0) {\n        pitchBend(d1);\n        pitchBend(d2);\n      }\n      if (echo) {\n        addEcho(d1Volume);\n        addEcho(d2Volume);\n      }\n      if (reverb) {\n        addReverb(d1Volume);\n        addReverb(d2Volume);\n      }\n      play(d1);\n      play(d2);\n    }\n\n    //The `play` function\n    function play(node) {\n      node.start(actx.currentTime + wait);\n    }\n  };\n\n  /*\n  impulseResponse\n  ---------------\n\n  The `makeSound` and `soundEffect` functions uses `impulseResponse`  to help create an optional reverb effect.  \n  It simulates a model of sound reverberation in an acoustic space which \n  a convolver node can blend with the source sound. Make sure to include this function along with `makeSound`\n  and `soundEffect` if you need to use the reverb feature.\n  */\n  ga.impulseResponse = function (duration, decay, reverse, actx) {\n\n    //The length of the buffer.\n    var length = actx.sampleRate * duration;\n\n    //Create an audio buffer (an empty sound container) to store the reverb effect.\n    var impulse = actx.createBuffer(2, length, actx.sampleRate);\n\n    //Use `getChannelData` to initialize empty arrays to store sound data for\n    //the left and right channels.\n    var left = impulse.getChannelData(0),\n      right = impulse.getChannelData(1);\n\n    //Loop through each sample-frame and fill the channel\n    //data with random noise.\n    for (var i = 0; i < length; i++) {\n\n      //Apply the reverse effect, if `reverse` is `true`.\n      var n;\n      if (reverse) {\n        n = length - i;\n      } else {\n        n = i;\n      }\n\n      //Fill the left and right channels with random white noise which\n      //decays exponentially.\n      left[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);\n      right[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);\n    }\n\n    //Return the `impulse`.\n    return impulse;\n  };\n  //plugins ends\n};\n"]}