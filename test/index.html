<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height">
<title>bazaar</title>
<style> * {margin: 0; padding: 0; overflow: hidden;} </style>
<body>
  <script src="ga.all.min.js"></script>
  <!-- <script src="ga.js"></script>
  <script src="plugins.js"></script> -->
  <script>

    /*
    This file requires these convenience functions from `plugins.js`:
    `hitTestTile`
    `getIndex`
    `getPoints`
    `makeTiledWorld`
    `worldCamera`
    */

    /*
    Ga supports game maps and levels created using the popular Tiled
    Editor level designer:
    
    www.mapeditor.org
       
    See the example `tileEditorSupport.html` for instructions on how to
    integrate Tiled Editor maps into your Ga code.
    
    Before you read this source code, take a close look at the
    'maps/fantasy.tmx' in Tiled Editor to see how it was structured.
    Observe how Tiled Editor's layers were used to create depth layers.
    Also notice that the hear, skull and marmot tileset images all have
    custom `name` properties so that they're easy to access in the game
    code.
    
    This is a rather extreme example. In a production level game you
    probably shouldn't blit so many individual tile sprites to so many 
    depth levels, for performance reasons. It would be better to use a
    single, solid background image for the whole game world, 
    and just use Tiled Editor's layers to generate arrays of obstacle and
    item positions. 
    */

    //Create a new GA instance, and start it.
    //Load the tileset PNG and the Tiled Editor JSON file

    var g = ga(512, 896, setup,
      [
        "res/ornament.png",
        "res/walkcycle.png",
        "res/puzzler.otf",
        "res/bazaar.json"
      ]
    );
    g.start();

    //Set the frames per second to 30
    g.fps = 30;

    //Declare global sprites, objects, and variables
    //that you want to access in all the game functions and states

    var world, mplayer, camera, last_face2;

    //A `setup` function that will run only once.
    //Use it for initialization tasks
    function setup() {

      //Make the world from the Tiled JSON data and the tileset PNG image
      world = g.makeTiledWorld(
        "res/bazaar.json",
        "res/ornament.png"
      );
      // function resize() {
      //       g.canvas.width = window.innerWidth;
      //       g.canvas.height = window.innerHeight;
      //   }
      //   window.addEventListener("resize", resize);
      //   resize();
      //Create the mplayer sprite using a filmstrip of animation frames
      mplayer = g.sprite(g.filmstrip("res/walkcycle.png", 64, 64));

      /*
      Tiled Editor lets you create generic objects. Take a look at the
      `fantasy.tmx` file you'll see that the mplayer sprite was actually
      created using of these generic objects. The object doesn't define
      the mplayer's appearance, only its size and position. We're going to use
      the object's data to position the mplayer sprite in the game world.
      Position the mplayer sprite in the same place as the mplayer object
      */
      var title = g.text("外星人") ;
      mplayer.x = world.getObject("mplayer").x;
      mplayer.y = world.getObject("mplayer").y;

      //Add the mplayer sprite the map's "objects" layer group
      var objectsLayer = world.getObject("players");
      objectsLayer.addChild(mplayer);
      objectsLayer.addChild(title);
      mplayer.putTop(title);
      mplayer.interactive = true;
      mplayer.release = function(){
        alert('You hit me');
      }
      //If you want to, add the sprite to a different world layer,
      //you can do it like this:
      //world.getObject("treeTops").addChild(mplayer);

      //Use `world.getObjects` to get an array of objects on the map
      //console.log(world.getObjects("marmot", "skull", "heart"));


      /*
      Create the camera and center it over the mplayer.
      The `worldCamera` method returns a `camera` object
      with `x` and `y` properties. It has
      two useful methods: `centerOver`, to center the camera over
      a sprite, and `follow` to make it follow a sprite.
      `worldCamera` arguments: worldObject, theCanvas
      The worldObject needs to have a `width` and `height` property.
      */

      camera = g.worldCamera(world, g.canvas);
      camera.centerOver(mplayer);

      //Define a `collisionArea` on the mplayer that will be sensitive to
      //collisions. `hitTestTile` will use this information later to check
      //whether the mplayer is colliding with any of the tiles

      mplayer.collisionArea = { x: 22, y: 44, width: 20, height: 20 };

      /*
      Define the mplayer's animation states. These are names that correspond
      to frames and frame sequences in the mplayer's animation frames. It's
      entirely up to you to decide what you want to call these states.
      Define animation sequences as a 2-value array:
    
          wallkleft: [startFrame, endFrame]
    
      The first value is the frame number that the sequence should start
      at, and the second value is the frame number that the sequence
      should end at.
      */

      mplayer.states = {
        up: 0,
        left: 9,
        down: 18,
        right: 27,
        walkUp: [1, 8],
        walkLeft: [10, 17],
        walkDown: [19, 26],
        walkRight: [28, 35]
      };

      //Use the `show` method to display the mplayer's `right` state
      last_face2 = mplayer.states.right;
      mplayer.show(last_face2);
      mplayer.fps = 18;

      //Create some keyboard objects
      leftArrow = g.keyboard(37);
      upArrow = g.keyboard(38);
      rightArrow = g.keyboard(39);
      downArrow = g.keyboard(40);

      //Assign key `press` and release methods that
      //show and play the mplayer's different states
      leftArrow.press = function () {
        mplayer.playSequence(mplayer.states.walkLeft);
        mplayer.vx = -2;
        mplayer.vy = 0;
      };
      leftArrow.release = function () {
        if (!rightArrow.isDown && mplayer.vy === 0) {
          mplayer.vx = 0;
          mplayer.show(mplayer.states.left);
        }
      };
      upArrow.press = function () {
        mplayer.playSequence(mplayer.states.walkUp);
        mplayer.vy = -2;
        mplayer.vx = 0;
      };
      upArrow.release = function () {
        if (!downArrow.isDown && mplayer.vx === 0) {
          mplayer.vy = 0;
          mplayer.show(mplayer.states.up);
        }
      };
      rightArrow.press = function () {
        mplayer.playSequence(mplayer.states.walkRight);
        mplayer.vx = 2;
        mplayer.vy = 0;
      };
      rightArrow.release = function () {
        if (!leftArrow.isDown && mplayer.vy === 0) {
          mplayer.vx = 0;
          mplayer.show(mplayer.states.right);
        }
      };
      downArrow.press = function () {
        mplayer.playSequence(mplayer.states.walkDown);
        mplayer.vy = 2;
        mplayer.vx = 0;
      };
      downArrow.release = function () {
        if (!upArrow.isDown && mplayer.vx === 0) {
          mplayer.vy = 0;
          mplayer.show(mplayer.states.down);
        }
      };
      var begin_x, begin_y, end_x, end_y;
      g.pointer.press = function () {
        begin_x = g.pointer.x;
        begin_y = g.pointer.y;

      };
      g.pointer.release = function () {
        end_x = g.pointer.x;
        end_y = g.pointer.y;
        var dx = end_x - begin_x;
        var dy = end_y - begin_y;
        var magnitude = Math.sqrt(dx * dx + dy * dy);
        dx /= magnitude;
        dy /= magnitude;
        mplayer.vy = dy * 2;
        mplayer.vx = dx * 2;
        clearTimeout(mplayer.fatigue_tm);
        (function fatigue(){
          mplayer.vx = Math.abs(mplayer.vx) > 0.5 ? Math.max(0, (Math.abs(mplayer.vx) - 0.1)) * Math.sign(mplayer.vx) : 0;
          mplayer.vy = Math.abs(mplayer.vy) > 0.5 ? Math.max(0, (Math.abs(mplayer.vy) - 0.1)) * Math.sign(mplayer.vy) : 0;
          if( Math.abs(mplayer.vx) > 0 || Math.abs(mplayer.vy) ) {
            mplayer.fatigue_tm = setTimeout(fatigue, 1000);
          }          
        })(); 
      };
      mplayer.can_play_anim = false;
      
      mplayer.animate = function(){
        mplayer.putTop(title);

        if(mplayer.vx == 0 && mplayer.vy == 0){
          mplayer.show(last_face2);
          mplayer.can_play_anim = true;
          return;
        }
        if(mplayer.vx > 0){
          if(mplayer.vx > Math.abs(mplayer.vy) ) {
            if(mplayer.can_play_anim || last_face2 != mplayer.states.right) {
              mplayer.playSequence(mplayer.states.walkRight);
              last_face2 = mplayer.states.right;
              mplayer.can_play_anim = false;
            }
            
          } else if(mplayer.vy > 0) {
            if(mplayer.can_play_anim || last_face2 != mplayer.states.down) {
              mplayer.playSequence(mplayer.states.walkDown);
              last_face2 = mplayer.states.down;
              mplayer.can_play_anim = false;
            }
          } else {
            if(mplayer.can_play_anim || last_face2 != mplayer.states.up) {
              mplayer.playSequence(mplayer.states.walkUp);
              last_face2 = mplayer.states.up;
              mplayer.can_play_anim = false;
            }
          }
        } else {
          if( Math.abs(mplayer.vx) > Math.abs(mplayer.vy) ) {
            if(mplayer.can_play_anim || last_face2 != mplayer.states.left) {
              mplayer.playSequence(mplayer.states.walkLeft);
              last_face2 = mplayer.states.left;
              mplayer.can_play_anim = false;
            }
          } else if(mplayer.vy > 0) {
            if(mplayer.can_play_anim || last_face2 != mplayer.states.down) {
              mplayer.playSequence(mplayer.states.walkDown);
              last_face2 = mplayer.states.down;
              mplayer.can_play_anim = false;
            }
          } else {
            if(mplayer.can_play_anim || last_face2 != mplayer.states.up) {
              mplayer.playSequence(mplayer.states.walkUp);
              last_face2 = mplayer.states.up;
              mplayer.can_play_anim = false;
            }
          }
        }
      }
      //Change the game state to `play`
      g.state = play;
    }

    //The `play` function will run in a loop
    function play() {
      mplayer.animate();
      //Move the mplayer and constrain it to the world boundaries
      //(-10 and -18 are to compensate for image padding around the sprite)
      mplayer.x = Math.max(-18, Math.min(mplayer.x + mplayer.vx, world.width - mplayer.width + 18));
      mplayer.y = Math.max(-10, Math.min(mplayer.y + mplayer.vy, world.height - mplayer.height));

      //Make the camera follow the mplayer
      camera.follow(mplayer);

      //Get a reference to the obstacles map array and use `hitTestTile`
      //check for a collision between the mplayer and the ground tiles
      //(See the example `tiledEditorSupport.html` for details on how to
      //`hitTestTile` - it's not difficult)
      var obstaclesMapArray = world.getObject("obstacles").data;
      var elfVsGround = g.hitTestTile(mplayer, obstaclesMapArray, 0, world, "every");

      //If the mplayer isn't touching any ground tiles, it means its touching
      //an obstacle, like a bush, the bottom of a wall, or the bottom of a
      //tree
      if (!elfVsGround.hit) {
        //To prevent the mplayer from moving, subtract its velocity from its position
        mplayer.x -= mplayer.vx;
        mplayer.y -= mplayer.vy;
        mplayer.vx = 0;
        mplayer.vy = 0;

        //You can find the gid number of the thing the mplayer hit like this:
        //console.log(obstaclesMapArray[elfVsGround.index]);
      }

    }

  </script>
</body>